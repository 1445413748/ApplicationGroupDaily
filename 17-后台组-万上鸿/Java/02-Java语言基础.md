[toc]
## 2 java语言基础组成
### 2.1 java语言基础
#### 2.1.1 关键字
1. ==不可以用main,public等等关键字为变量名字==；
2. ==类名最好第一个字母大写==
#### 2.1.2 标识符
有26个英文字母大小写，数字，_$组成
1. ==数字不可以开头==
2. ==不可以使用关键字</br>==
==注意：java中严格区分大小写==
#### 2.1.3 注释
1.
```
/**
  文档注释

*/
```
2. 
`//单行注释`
3. 
```
/*
  多行注释

*/
```
#### 2.1.4 注释的应用
1. 可读性
2. javadoc.exe 可以观察到文本注释
### 2.2 常量
不能改变的变量
1. 整数常量。所有整数
2. 小数常量。
3. 布尔（boolean)型
4. 字符常量。'A'
5. 字符串常量。"aefb"
6. null常量
### 2.3 进制
#### 2.3.1 进制的由来
二进制转化而来
#### 2.3.2 进制的转换
### 2.4 变量
#### 2.4.1 定义变量
定义变量的格式：  数据类型  变量名=初始值</br>

变量的最大值：int x1=Integer.MAX_VALUE;

强制转换：在前面加： (强制类型)</br>
int x=3;</br>
byte b=5;</br>
x=x+b;</br>
byte b=3;</br>
b=(byte)(b+200);</br>

==注意：byte字节就是一个八位元组，它的值域被定义为-128~127。==
#### 2.4.2 字符类型运算过程
System.out.printlmn('你'+1);//unicode国际标准码表: 输出结果是：20321

==注意：System.out.printlmn("你"+1);//输出结果是：你1==
### 2.5 运算符
#### 2.5.1 算术运算符
如：+&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;%（取余，模运算）&nbsp;&nbsp;&nbsp;+（连接符）
#### 2.5.2 赋值运算符
如：=&nbsp;&nbsp;&nbsp;+=&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;-=&nbsp;&nbsp;&nbsp;*=&nbsp;&nbsp;&nbsp;/=&nbsp;&nbsp;&nbsp;%=
#### 2.5.3 比较运算符
==&nbsp;&nbsp;&nbsp;!=&nbsp;&nbsp;&nbsp;<&nbsp;&nbsp;&nbsp;>&nbsp;&nbsp;&nbsp;<=&nbsp;&nbsp;&nbsp;>=</br>
返回必须是：true和false
#### 2.5.4 逻辑运算符
&（AND）&nbsp;&nbsp;&nbsp;|（or）&nbsp;&nbsp;&nbsp;^(XOR)&nbsp;&nbsp;&nbsp;!(NOT)&nbsp;&nbsp;&nbsp;&&(AND)&nbsp;&nbsp;&nbsp;||(AND)&nbsp;&nbsp;&nbsp;</br>
`System.out.println(x>2&x<5);`</br>
`System.out.println(x<2|x>5);`

区别：
1. 单个|和&:两边都参与运算
2. ||和&&:先判断一边，另一半可能不用运算。例如：|的左边如果正确，则右边不用运算了。
#### 2.5.5 位运算符
1. << （左移） 相当于乘于2的倍数
2. \>> （右移） 相当于除于2的倍数
3. &&nbsp;&nbsp;&nbsp;6&3=2&nbsp;&nbsp;&nbsp;基于二进制来运算，对应的位，0为假，1为真，用&来判断
4. || （原理同上） 6|3=7
5. ^ 相同为假，不同为真。一个数异或同一个数两次，结果还是这个数。
6. \>>>无符号右移</br>
例如：对两个整数变量值进行互换（不需要第三方变量）</br>
方法一：
```
    int c;
    c=a;
    a=b;
    b=c;
```
开发时用，使用第三方变量的形式，阅读性强</br>
方法二：
```
    a=a+b;
    b=a-b; 
    a=a-b;
```
数据较大的时候，会强制转换，数据会改变。</br>
方法三：
``` 
a=a^b;
b=a^a;
a=a^b;
```
面试时用
#### 2.5.6 三元运算符
格式：&nbsp;&nbsp;(条件表达式)?表达式1:表达式2;</br>
若真，返回表达式1，反之，返回表达式2。
### 2.6 程序流程控制
#### 2.6.1 条件结构
1.
 ```
 if(条件表达式)
 {
     执行语句
 }
```
2. 
```
if(条件表达式){
    执行语句
}
else {
    执行语句
}
```
#### 2.6.2 选择结构
switch语句</br>
格式：</br>
```
    switch(表达式)
    {
        case 取值1:
        执行语句;
        break;
        ……
        default:
        执行语句;
        break;
    }
```
if和switch 的应用
1. if:
   1. 对具体的值进行判断。
   2. 对区间判断
   3. 对运算结果是Boolean类型的表达式进行判断
  
2. switch
   1. 对具体值进行判断
   2. 值的个数通常是固定的
 
对于几个固定的值判断，建议使用switch语句，因为switch语句会将具体的答案都加载进内用内存，效率相对高。
#### 2.6.3 循环结构
1. while语句
```
 while(条件表达式)
 {
     执行语句
 }
``` 
2. do while语句
```
do{
    执行语句
}while(条件表达式)
```
3. for语句
```
for(初始化表达式;循环条件表达式;循环后的操作表达式){
    循环语句;
}

```
for语句还可以嵌套


for和while的特点
1. for和while可以互换
2. 格式上的不同，在使用上有点小区别。</br>
    如果需要通过变量来对循环进行控制，该变量只作为循环增量存在时，区别就体现了。
#### 2.6.4 其他程序控制语句
1. break(跳出)
2. continue(继续)
### 2.7 函数
#### 2.7.1  定义函数的格式
```
修饰符 返回值类型 函数名(参数列表)
{
   执行语句;
   return 返回值;
}
```
无返回值类型则为void，以return;结尾，可以省略。

注意：函数的级别，要和main主函数同级别，public static
#### 2.7.2 函数重载
函数名相同，参数列表不同。</br>
例如：
1. void Test(int a)和void Test(char a)重载
2. int Test(int a,int b)和char Test(char a,char b)重载

等等....
### 2.8 数组
#### 2.8.1 数组的定义
1. 格式1：</br>
元素类型[]数组名=new 元素类型[元素个数或数组长度];</br>
示例：`int [] arr = new int[5];`</br>
 区别：声明和内存分配分开的，先声明，后内存分配，初始化时由程序员指定数组的长度，由系统决定 每个数组元素的初始值,系统默认的初始值为0。</br>
2. 格式2：</br>
元素类型[]=new 元素类型[]{元素1，元素2...};</br>
示例：`int [] arr = new int[]{3,5,1,7};`</br>
区别：声明和内存分配分开的，先声明，后内存分配，初始化时数组的长度和数组元素的初始值都由程序员指定。
3. 格式3：（静态）
 数据类型 [] 名字={值1,值2,值3....};</br>
 例如：`int [] a = {1,2,3...};`
 区别：初始化时由程序员指定每个数组元素的初始值，由系统决定数组的长度。
#### 2.8.2 内存划分
1.寄存器</br>
2.本地方法区</br>
3.方法区</br>
4.栈内存</br>
   存储的都是局部变量</br>
   而且变量所属的作用域一旦结束，该变量就会自动释放。</br>
注意：main主函数里面的都是局部变量，即存在栈内存里面

```
{//main主函数里面
//局部代码块，限定局部变量的生命周期
    int age=3;
}
```
5.堆内存</br>
存储是数组和对象（其实数组就是对象）凡是new建立在堆中。</br>
例如：int [] arr=new int[3];</br>
==arr是局部变量，存在栈里面</br>
new int[3]是数组对象，存在堆内存里面</br>==
特点：
1. 每个实体都有首地址。
2. ==堆内存中的每一个变量都有默认初始化值，根据类型的不同而不同。==
3. ==垃圾回收机制。==
#### 2.8.3 数组的常见操作
[选择排序法](https://blog.csdn.net/qq_32914323/article/details/49931691)
可以用swap(三个形参)函数，进行交换位置。</br>
[冒泡法](https://blog.csdn.net/u012403290/article/details/70598262)：可以用Arrays.sort(参数)函数来实现。</br>
[折半查找](https://blog.csdn.net/woaigengxiaoning/article/details/51108589)：可以用Arrays.binarySearch(数组,值)函数;
#### 2.8.4 进制的转换
一个32位的数，转成十六进制：
```
for(int x=0;x<8;x++)
{
    int temp=num&15;
    if(temp>9)
        System.out.println((char)(temp-10+'A'));
    else 
        System.out.println(temp); 
    num=num>>>4;
}
```
[查表法](https://blog.csdn.net/uotail/article/details/71104451
)：根据运算结果作为角标直接去查数组中对应的元素即可</br>

可以用 ==Integer.toBinaryString(数值)== 函数实现整数二进制的转换
#### 2.8.5 数组中的数组
1. 格式1： `int [][] arr = new int[3][2];`
2. 格式2： `int [][] arr = new int [3][];`</br>
注意：每个一维数组都是默认初始化值null</br>
可以对这个三个一维数组分别进行初始化。
```
arr[0]=new int[3];
arr[1]=new int[3];
arr[2]=new int[3];
```
[I@1fb8ee3</br>
@左边为实体的类型。@右边是实体的哈希值
3. 格式3：`int [][] arr ={{3,1,7},{5,8,2,9},{4,1}};`
注意：每一个一维数组的长度可能不一样，在遍历的时候应该。

```
for(int x=0;x<arr.length;y++)
{
    for(int y=0;y<arr[x].length;y++)
    {
        System.out.println(arr[i][j]);
    }
}
```
另一种格式：

```
//甲:30 59 28 17
//乙:37 60 22 19
int [] arr = {{30,59,28,17},{37,60,22,19}};