[toc]
# 1.基本数据类型对象包装类
## 1.1 基本数据类型对象包装类
1. 将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作数据
2. 常用的操作之一：用于基本数据类型与字符串之间的转换。

基本数据类型对象包装类。</br>
为了方便操作基本类型值，将封装成了对象，在对象中定义了属性和行为丰富了该数据的操作。</br>
用于描述该对象的类就称为基本类型对象包装类。</br>
byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Byte</br>
short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Short</br>
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integet</br>
long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Long</br>
float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Float</br>
double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Double</br>
char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Character</br>
boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Boolean</br>

该包装类对象主要用基本类型和字符串之间的转换

基本类型-->字符串</br>
1. 基本类型数值+"";
2. 用String类中的静态方法valueOf(基本类型数值)

字符串-->基本类型
1. 使用包装类中的静态方法xxx parseXxx("xxx类型的字符串");</br>
int parseInt("intstring");</br>
long parseLong("longstring");</br>
boolean parseBoolean("booleanstring");</br>

只有Character没有parse方法
2. 如果字符串被Integer进行对象封装。
   1. 可以使用另一个非静态的方法，intValue();
   2. 将一个Integer对象转成基本数据类型值。

## 1.2 进制
十进制--->其他进制</br>
Integer.toBinaryString();</br>
Integer.toOctalString();</br>
Integer.toHexString();</br>

其他进制--->十进制</br>
System.out.println(Integer.parseInt("3C",2);

## 1.3 自动装箱拆箱
Integer i=4;//i=new Integer(4);自动装箱，简化书写

i=i+6;//i=new Integer(i.intValue()+6);//i.intValue()  自动拆箱

面试：

Integer a=new Integer(127);
Integer b=new Integer(127);

System.out.println(a==b);//false
System.out.println(a.equals(b));//true

Integer x= Integer(127);//自定装箱，如果装箱的是一个字节，那么该数据会被共享，不会重新开辟空间。
Integer y= Integer(127);

System.out.println(x==y);//true
System.out.println(x.equals(y));//true

# 2.集合类
集合类的由来：

对象用于封装持有数据，对象多了需要存储，如果对象的个数不确实。</br>
就使用集合容器进行存储。

集合的特点：

1. 用于存储对象的容器
2. 集合的长度是可变的
3. 集合中不可以存储基本数据类型值

集合容器因为内部的数据结构不同，有多种具体容器。
不断的向上抽取，就形成了集合框架

框架的顶层Collection接口

collection的常见的方法：
1. 添加：
Boolean add(Object obj);</br>
boolean addAll(Collection coll);
2. 删除
boolean remove(Object obj);</br>
boolean removeAll(Collection coll);</br>
void clear();(集合还在)

3. 判断
boolean contains(object obj)</br>
boolean containAll(Collection coll);</br>
boolean ifEmpty();判断集合中是否有元素

4. 获取：
int size();</br>
Iterator iterator();取出元素的方式，迭代器。</br>
该对象必须依赖于具体容器，因为每一个容器的数据结构不同。</br>
所以该迭代器对象是在容器中进行内部实现的。</br>
对于使用容器者而言，具体的实现不重要，只要通过容器获取到该实现的迭代器的对象即可，也就是iterator方法。

Iterator接口就是对所有的collection容器进行元素取出的公共接口

5. 其他：
boolean retainAll(Collection coll);取交集
Object [] toArray();将集合转成数组。

 迭代器使用
 
使用了collection中iterator()方法。调用集合中的迭代器方法，是为了获取集合中的迭代器对象。</br>
Iterator it=new Iterator();
```
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class IteratorDemo
{
    public static void main(String[]args)
    {
        Collection coll=new ArrayList();
        coll.add("abc1");
        coll.add("abc2");
        coll.add("abc3");
        coll.add("abc4");
        //使用了collection中iterator()方法。调用集合中的迭代器方法，是为了获取集合中的迭代器对象。
        /*
        Iterator it=coll.Iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }*/
        for(Iterator it=coll.iterator();it.hasNext();)
        {
            System.out.println(it.next());
        }
        //System.out.println(it.next());
       // System.out.println(it.next());
    }
}
```
## 2.1 集合框架-List
**集合框架-List和Set的特点**

Collection：
1. --List：有序(存入和取出的顺序一致)，元素都有索引（角标），元素可以重叠。
2. --Set：元素不可以重复，无序。

**List：特有常见方法**

有一个特性特点就是可以操作角标
1. 添加</br>
void add(index,element);</br>
void add(index,collection);
2. 删除</br>
Object remove(index);
3. 修改</br>
Object set(index,element);
4. 获取</br>
Object get(index);</br>
int indexOf(object);</br>
int lastIndexOf(object);</br>
Last subList(from,to);

List集合是可以完成对元素的增删改查

注意：集合和迭代器同时在对元素进行修改，会出现异常。</br>
在迭代器过程中，不要使用集合操作元素，容易出现异常，可以使用Iterator接口的子接口ListIterator来完成
```
import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;

public class Test03
{
	public static void main(String[]args)
	{
		List list=new ArrayList();
		list.add("abc1");
		list.add("abc2");
		list.add("abc3");
    
	    System.out.println("List:"+list);
	    ListIterator it=list.listIterator();//获取列表迭代器对象
	    //它可以实现在迭代过程中完成对元素的增删改查。
	    //注意：只有List集合具备该迭代功能
	    while(it.hasNext())
	    {
	        Object obj=it.next();
	        
	        if(obj.equals("ab2")){
	            it.set("abc9");
	        }
	    }
	    while(it.hasPrevious())
	    {
	        System.out.println("Previous:"+it.hasPrevious());
	    }
	    System.out.println("List:"+list);
	    
	    while(it.hasNext())
	    {
	        System.out.println("hasNext:"+it.hasNext());
	    }
	    System.out.println("List:"+list);
	}
}
```

**List 常用的子句的特点**

1. --Vector:内部是数组数据结构。是同步的，增删，查询都很慢。
2. --ArrayList:内部是数组数据结构，是不同步的。替代了Vector。查询速度快。
3. --LinkedList:内部是链表数据结构，是不同步的。增删元素的速度非常快。

### 2.1.1 集合框架-Vector集合
```
import java.util.Enumeration;
import java.util.Iterator;
import java.util.Vector;

public class Test03
{
    public static void main(String[]args)
    {
    	Vector v=new Vector();
        v.addElement("abc1");
        v.addElement("abc2");
        v.addElement("abc3");
        v.addElement("abc4");
        
        Enumeration en=v.elements();
        while(en.hasMoreElements())
        {
            System.out.println("nextelement:"+en.nextElement());
        }
        
        Iterator it=v.iterator();
        while(it.hasNext())
        {
            System.out.println("next:"+it.next());
        }
    }
}

```
要输出 Vector<E> v 的所有元素，可使用以下方法： 
```
for (Enumeration<E> e = v.elements(); e.hasMoreElements();)
   System.out.println(e.nextElement());
```

### 2.1.2 LinkedList
```
import java.util.Iterator;
import java.util.LinkedList;

public class Test03
{
    public static void main(String[]args)
    {
        LinkedList link=new LinkedList();
        
        link.addFirst("abc1");
        link.addFirst("abc2");
        link.addFirst("abc3");
        link.addFirst("abc4");
        
        Iterator it=link.iterator();
        while(it.hasNext())
        {
            System.out.println(it.next());
        }
        
        while(it.hasNext())
        {
            System.out.println("next:"+it.next());
        }
        //输出结果：abc4
        //          abc3
        //          abc2
        //          abc1
        System.out.println(link);
        //输出：[abc4,abc3,abc2,abc1]
        System.out.println(link.getFirst());
        //获取第一个但不能删除
        System.out.println(link.removeFirst());
        //获取元素但不删除
        while(!link.isEmpty())
        {
            System.out.println(link.removeLast());
        }
    }
}
```

请使用LinkedList来模拟一个堆栈和者队列数据结构

堆栈：先进后出 First In Last Out   (FILO)

队列：先进先出First In First Out   (FIFO)

我们应该描述这样一个容器，给使用提供一个容器对象完成这两种结构中的一种
```
class DuiLie{
    private LinkedList link;
    DuiLie(){
        link =new LinkedList();
    }
    public void myAdd(Object obj)
    {
        link.addLast(obj);
    }
    public Object myGet(){
        return link.removeFirst();
    }
}
```
LinkedList:

addFirst();</br>
addLast();</br>
jdk1.6</br>
offerFirst;</br>
offerLast;

getFirst();//获取但不移除，如果链表为空，抛出NoSuchElementException</br>
getLast();</br>
jdk1.6</br>
peekFirst();//获取但不移除，如果链表为空，返回null</br>
peekLast();

removeFirst();//获取并移除，如果链表为空，抛出NoSuchElementException。</br>
removeLast();</br>
jdk1.6</br>
pollFirst();//获取并移除，如果链表为空，返回null</br>
pollLast

### 2.1.3 ArrayList集合存储自定义对象
```
public class ArrayListTest
{
    public static void mian(String[]args)
    {
        ArrayList a1=new ArrayList();
        a1.add(new Person("lisi1",21));
        a1.add(new Person("lisi2",22));
        a1.add(new Person("lisi3",23));
        a1.add(new Person("lisi4",24));
        
        Iterator it=a1.iterator();
        while(it.hasNext)
        {
            //System.out.println(((person)it.next()).getName());//由于object中没有name，用getName()不能取得到，所以要向下转换类型
            Person p=(Person)it.next();
            System.out.println(p.getName()+"::"+p.getAge());
        }
    }
}
```
## 2.2 集合框架-Set
Set：元素不可以重复，是无序。</br>
set接口中的方法和Collection一致。
### 2.2.1 HashSet集合
1. ---HashSet:内部数据结构是哈希表，是不同步的
```
public class HashSetTest
{
    public static void mian(String[]args)
    {
        HashSet hs=new HashSet();
        hs.add("hehe");
        hs.add("heihei");
        hs.add("hahah");
        hs.add("xixix");
        
        Iterator it=sh.iterator();
        while(it.hasNext)
        {
            System.out.println(it.next());
        }
    } 
}
```
哈希表确定元素是否相同
1. 判断的是两个元素的哈希值是否相同。</br>
如果相同，在判断两个对象的内容是否相同

2. 判断哈希值相同，其实判断的是对象的hashCode的方法，判断内容相同，用的是equals方法。

注意：如果哈希值不同，是不需要判断equals()。

HashSet集合数据结构是哈希表，所以存储元素的时候</br>
使用的元素的hashCode方法来确定位置，如果位置相同，在通过元素的equals来确定是否相同。</br>
如：
```
class Person extends Object
{
    private String name;
    private int age;
    
    public Person()
    {
        super();
    }
    
    public Person(String name,int age)
    {
        super();
        this.name=name;
        this.age=age;
    }
    public String getName()
    {
        return name;
    }
    public void setName(String name)
    {
        this.name=name;
    }
    
    public int hashCode()
    {
        System.out.println(this+"..............hashCode");
        return name.hashCode()+age;
    }
    
    public boolean equals(Object obj)
    {
        if(this==obj)
            return true;
        if(!(obj instanceof Person))
            throw new ClassCastException("类型错误");
        System.out.println(this+"...equals..."+obj);
        Person p=(Person)obj;
        return this.name.equals(p.name)&&this.age==p.age;
    }

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}
}

import java.util.HashSet;
import java.util.Iterator;
public class Test03
{
    public static void mian(String[]args)
    {
        HashSet hs=new HashSet();
        hs.add(new Person("lisi4",24));
        hs.add(new Person("lisi7",27));
        hs.add(new Person("lisi1",21));
        hs.add(new Person("lisi9",29));
        hs.add(new Person("lisi7",27));
        
        Iterator it=hs.iterator();
        while(it.hasNext())
        {
            Person p=(Person)it.next();
            System.out.println(p.getName()+"...."+p.getAge());
        }
    } 
}
```
包含一个元素是否存在：

ArrayList:contains：equals

hashSet:hashCode和equals

### 2.2.2 LinkedHashSet集合
```
public class LinkedHashSetTest
{
    public static void mian(String[]args)
    {
        HashSet hs=new LinkedHashSet();
        hs.add(new Person("lisi4",24));
        hs.add(new Person("lisi7",27));
        hs.add(new Person("lisi1",21));
        hs.add(new Person("lisi9",29));
        hs.add(new Person("lisi7",27));
        
        Iterator it=sh.iterator();
        while(it.hasNext)
        {
            Person p=(Person)it.next();
            System.out.println(p.getName+"...."+p.getAge());
        }
    } 
}
```
### 2.2.3 TreeSet集合
#### 2.2.3.1 compareTo()函数进行覆盖
--TreeSet:可以对Set集合中的元素进行排序。</br>
判断元素唯一性的方式：就是根据比较方法的返回结果是否为0，是0，就是相同元素，不存。
```
public class TreeSetTest
{
    public static void mian(String[]args)
    {
        TreeSet ts=new TreeSet();
        ts.add("abc");
        ts.add("ab");
        ts.add("a";
        ts.add("zds");
        ts.add("sf");
        
        Iterator it=ts.iterator();
        while(it.hasNext)
        {
            System.out.println(it.next());
        }
    } 
}
```
对compareTo()函数进行覆盖
```
class Person extends Object implements Comparable
{
    private String name;
    private int age;
    
    public Person()
    {
        super();
    }
    
    public Person(String name,int age)
    {
        super();
        this.name=name;
        this.age=age;
    }
    public String getName()
    {
        return name;
    }
    public void setName(String name)
    {
        this.name=name;
    }
    
    public int hashCode()
    {
        System.out.println(this+"..............hashCode");
        return name.hashCode()+age;
    }
    
    public boolean equals(Object obj)
    {
        if(this==obj)
            return true;
        if(!(obj instanceof Person))
            throw new ClassCastException("类型错误");
        System.out.println(this+"...equals..."+obj);
        Person p=(Person)obj;
        return this.name.equals(p.name)&&this.age==p.age;
    }
    public int compareTo(Object o)
    {
        Person p=(Person)o;
        
        int temp=this.age-p.age;
        return temp==0?this.name.compareTo(p.name):temp;
        
        
        /*if(this.age>p.age)
            return 1;
        if(this.age<p.age)
            return -1;
        else
            return this.name.compareTo(p.name);*/
    }
}
```
TreeSet对元素进行排序的方式一：</br>
让元素自身具备比较功能，元素需要实现comparable接口。覆盖compareTo方法。</br>
如果不要按照对象中具备的自然顺序进行排序。如果对象中不具备自然顺序。</br>

如果不要按照对象中具备的自然顺序进行排序，如果对象中不具备自然顺序，怎么办？</br>
可以使用TreeSet集合第二种排序方式二：</br>
让集合自身具备比较功能。定义一个类实现Comparator接口，覆盖compare方法。</br>
将该类对象作为参数传递给TreeSet集合的构造函数。
#### 2.2.3.2 TreeSet集合-Comparator比较器
```
public class Person {
	private String name;
	private int age;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public Person(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}
}

import java.util.Comparator;
import java.util.Iterator;
import java.util.TreeSet;
public class ComparatorByName implements Comparator
{
    public int compare(Object o1,Object o2)
    {
        Person p1=(Person)o1;
        Person p2=(Person)o2;
        
        int temp=p1.getName().compareTo(p2.getName());
        
        return temp==0?p1.getAge()-p2.getAge():temp;
    }
}
public class Test03
{
    public static void mian(String[]args)
    {
        TreeSet ts=new TreeSet(new ComparatorByName());
        ts.add(new Person("lisi4",24));
        ts.add(new Person("lisi7",27));
        ts.add(new Person("lisi1",21));
        ts.add(new Person("lisi9",29));
        ts.add(new Person("lisi7",27));
        
        Iterator it=ts.iterator();
        while(it.hasNext())
        {
            Person p=(Person)it.next();
            System.out.println(p.getName()+"...."+p.getAge());
        }
    } 
}
```
## 2.3 Map
### 2.3.1 特点
一次添加一对元素。Collection一次添加一个元素</br>
其实map集合中存储的就是键值对</br>
map集合中必须保证键的唯一性。

常用方法：
1. 添加
value put(key,value);返回前一个和key关联的值，如果没有，返回null
2. 删除
void clear();清空map集合。</br>
value remove(key);根据指定的key翻出这个键值对。
3. 判断
boolean containsKey(key);</br>
boolean containsKey(value);</br>
boolean isEmpty();
4. 获取
value get(key):通过键获取值，如果没有该键返回null.
当然可以通过返回null，来判断是否包含指定键。</br>
int size();获取键值对的个数
```
import java.util.HashMap;
import java.util.Map;
public class Test03{
    public static void main(String[]args)
    {
        Map<Integer,String> map=new HashMap<Integer,String>();
        method(map);
    }
    
    public static void method(Map<Integer,String> map)
    {
        //添加元素
        System.out.println(map.put(8,"wangcai"));//null
        System.out.println(map.put(8,"xiaoqiang"));//wangcai 存相同键，值会覆盖
        map.put(2,"zhangsan");
        map.put(7,"zhaosi");
        System.out.println(map);
        
        //删除。
        System.out.println("remove:"+map.remove(2));
        
        //判断。
        System.out.println("containskey:"+map.containsKey(7));
        
        //获取。
        System.out.println("get:"+map.get(8));
    }
}
```
### 2.3.2 keySet

取出map中的所有元素</br>
原理：通过keySet方法来获取map中所有的键所在的Set集合，再通过set的迭代器获取到每一个键</br>
在对每一个键通过map集合的get方法获取其对应的值即可。
```
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
public class Test03{
    public static void main(String[]args)
    {
        Map<Integer,String> map=new HashMap<Integer,String>();
    }
    
    public static void method(Map<Integer,String> map)
    {
        
        map.put(8,"wangcai");
        map.put(3,"xiaoqiang");
        map.put(2,"zhangsan");
        map.put(7,"zhaosi");
        
        //取出map中的所有元素
        //原理：通过keySet方法来获取map中所有的键所在的Set集合，再通过set的迭代器获取到每一个键
        //在对每一个键通过map集合的get方法获取其对应的值即可。
        
        Set<Integer> keySet=map.keySet();
        
        Iterator<Integer> it=keySet.iterator();
        
        while(it.hasNext())
        {
            Integer key=it.next();
            String value=map.get(key);
            System.out.println(key+":"+value);
        }
    }
}
```
### 2.3.3 entrySet
通过Map转成set就可以迭代。
找到了另一个方法。entrySet.
该方法将键和值的映射关系存储到了Set集合中，而这个映射关系的类型就是Map,Entry类型(结婚证)

**Set<Map.Entry<Integer,String>> entrySet=map.entrySet();**
```
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
public class Test03{
    public static void main(String[]args)
    {
        Map<Integer,String> map=new HashMap<Integer,String>();
    }
    
    public static void method(Map<Integer,String> map)
    {
        
        map.put(8,"wangcai");
        map.put(3,"xiaoqiang");
        map.put(2,"zhangsan");
        map.put(7,"zhaosi");
        
        Set<Map.Entry<Integer,String>> entrySet=map.entrySet();
        
        Iterator<Map.Entry<Integer,String>> it=entrySet.iterator();
        
        while(it.hasNext())
        {
            Map.Entry<Integer,String> me=it.next();
            Integer Key=me.getKey();
            String value=me.getValue();
            System.out.println(Key+":::"+value);
        }
    }
}
```
### 2.3.4 values
```
Collection <String> values=map.values();
Iterator<String> it=values.iterator();
while(it.hasNext()){
    System.out.println(it.next());
}
```
### 2.3.5 Map集合——常用的子类
1. |--Hashtable:内部结构是哈希表是同步的。不允许null作为键，null作为值。
   1. |---Properties: 用来存储键值对型的配置文件的信息，可以和IO技术相结合。
2. |--HashMap：内部结构是哈希表，不是同步的。不允许null作为键，null作为值。
3. |--TreeMap：内部结构是二叉树，不是同步的。可以对Map集合中的键进行排序。
### 2.3.6 Map集合——HashMap存储自定义对象
```

public class Student {
	private String name;
	private int age;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public Student(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}
}

import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;

public class Test03
{
    public static void main(String[]args)
    {
        //将学生对象和学生的归属地通过键与值存储到Map集合中
        HashMap<Student,String> hm=new HashMap<Student,String>();
        
        hm.put(new Student("lisi",38),"北京");
        hm.put(new Student("zhaoliu",24),"上海");
        hm.put(new Student("xiaoqiang",31),"沈阳");
        hm.put(new Student("wangcai",2),"大连");
        
        Set<Student> s=hm.keySet();
        
        Iterator<Student> it=s.iterator();
        
        while(it.hasNext()){
            Student key=it.next();
            String value=hm.get(key);
            System.out.println(key.getName()+":"+key.getAge()+"---"+value);
        }
    }
}
```
### 2.3.6 Map集合-TreeMap
```
import java.util.Iterator;
import java.util.Map;
import java.util.TreeMap;

public class Test03
{
    public static void main(String[]args)
    {
    	TreeMap<Student,String> tm=new TreeMap<Student,String>();
        
        tm.put(new Student("lisi",38),"北京");
        tm.put(new Student("zhaoliu",24),"上海");
        tm.put(new Student("xiaoqiang",31),"沈阳");
        tm.put(new Student("wangcai",2),"铁岭");
        
        Iterator<Map.Entry<Student,String>> it=tm.entrySet().iterator();
        
        while(it.hasNext())
        {
            Map.Entry<Student,String> me=it.next();
            Student key=me.getKey();
            String value=me.getValue();
        }
    }
}
```
### 2.3.7 Map集合-LinkedHashMap&关键词
```
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

public class Test03
{
    public static void main(String[]args)
    {
    	HashMap<Integer,String> hm=new HashMap<Integer,String>();
        
        hm.put(7,"zhouqi");
        hm.put(3,"zhangsan");
        hm.put(1,"qianyi");
        hm.put(5,"wangwu");
        
        Iterator<Map.Entry<Integer,String>>it=hm.entrySet().iterator();
        
        while(it.hasNext())
        {
            Map.Entry<Integer,String> me=it.next();
            
            Integer key=me.getKey();
            String value=me.getValue();
            
            System.out.println(key+":"+value);
        }
    }
}
```
### 2.3.8 记录字母次数思路
练习：</br>
"fdqavcbsacfs"获取该字符串中，每一个字母出现的次数。</br>
要求打印结果是：a(2),b(1)...;</br>
思路：</br>
对于结果分析发现，字母和次数之间存在着映射的关系。而且这种关系很多。</br>
很多就需要存储，能存储映射关系的容器有数组和Map集合。</br>
关系一，方式有序编号吗？没有！</br>
那就是使用Map集合。</br>
那就是使用Map集合，又发现可以保证唯一性的一方具备着顺序如：a  b  c ....</br>
所以可以使用TreeMap集合

这个集合最终应该存储的是字母和次数的对应关系。

1. 因为操作的是字符串中的字母，所以先将字符串变成字符串数组。
2. 遍历字符数组，用每一个字母作为键去查Map集合这个表。</br>
如果该字母键不存在，就将该字母作为键1作为值存储到map集合中。</br>
如果该字母键存在，就将该字母键对应值取出并+1，在将字母和+1后的值存储到map集合中，</br>
键相同值会覆盖，这样子就记录了该字母的次数。
3. 遍历结束，map集合就记录所有字母出现的次数。oy
```
import java.util.Iterator;
import java.util.Map;
import java.util.TreeMap;

public class Test03
{
    public static void main(String[]args)
    {
        String str="fdgavcbsacdfs";
        
        String s=getCharCount(str);
        
        System.out.println(s);
    }
    public static String getCharCount(String str)
    {
        //将字符串变成字符串数组
        char[]chs=str.toCharArray();
        
        //定义map集合表
        Map<Character,Integer> map=new TreeMap<Character,Integer>();
        
        for(int i=0;i<chs.length;i++)
        {
            if(!(chs[i]>='a'&&chs[i]<='z'||chs[i]>='A'&&chs[i]<='Z'))
                continue;
            //将数组中的字母作为键去查map表
            Integer value=map.get(chs[i]);
            //判断是否为null
            if(value==null)
            {
                map.put(chs[i],1);
            }
            else{
                map.put(chs[i],value+1);
            }
            
            
        }
        return map.toString();     //返回
    }
    private static String mapToString(Map<Character,Integer> map)
    {
        StringBuilder sb=new StringBuilder();
        
        Iterator<Character> it=map.keySet().iterator();
        
        while(it.hasNext())
        {
            Character key=it.next();
            Integer value=map.get(key);
            
            sb.append(key+"("+value+")");
        }
        return sb.toString();
    }
}
```
### 2.3.9 Map查表法
```
import java.util.HashMap;
import java.util.Map;

public class Test03
{
    public static void main(String[]args)
    {
        /*Map在有映射关系时，可以优先考虑。
         在查表法中的应用较为多见。*/
         String week =getWeek(1);
         System.out.println(week);
         
         System.out.println(getWeekByMap(week));
    }
    
    public static String getWeekByMap(String week)
    {
        Map<String,String> map =new HashMap<String,String>();
        map.put("星期一","Mon");
        map.put("星期二","Tus");
        map.put("星期日","Sun");
        map.put("星期三","Wes");
        map.put("星期天","Sun");
        
        return map.get(week);
    }
    public static String getWeek(int week)
    {
        if(week<1||week>7)
            throw new RuntimeException("没有对应的星期，请你重新输入");
            
        String []weeks={"","星期一","星期二"};
        
        return weeks[week];
    }
}
```
## 2.4 集合框架——工具类
### 2.4.1 集合框架-工具类-Collections-排序
```
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
public class CollectionsTest {
	public static void main(String []args)
    {
        List<String> list=new ArrayList<String>();
    
        list.add("abcde");
        list.add("cba");
        list.add("aa");
        list.add("zzz");
        list.add("cba");
        list.add("nbaa");
        System.out.println(list);
    
        //对list集合进行指定顺序的排序。
        Collections.sort(list);
        System.out.println(list);
    }

    public static <T extends Comparable<? super T>> void mySort(List<T> list)
    {
        for(int i=0;i<list.size()-1;i++)
        {
            for(int j=i+1;j<list.size();j++)
            {
                if(list.get(i).compareTo(list.get(j))>0){
                    T temp=list.get(i);
                    list.set(i,list.get(j));
                    list.set(j,temp);
                }
            }
        }
    }
}
```
加比较器
```
import java.util.Comparator;

public class ComparatorByLength implements Comparator<String>
    {
        public int compare(String o1,String o2)
        {
            int temp=o1.length()-o2.length();
        
            return temp==0?o1.compareTo(o2):temp;
        }
    }


import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
public class CollectionsTest {
	public static void main(String []args)
    {
        List<String> list=new ArrayList<String>();
    
        list.add("abcde");
        list.add("cba");
        list.add("aa");
        list.add("zzz");
        list.add("cba");
        list.add("nbaa");
        System.out.println(list);
    
        //对list集合进行指定顺序的排序。
        mySort(list,new ComparatorByLength());
        System.out.println(list);
    }
    public static <T>void mySort(List<T> list,Comparator<? super T> comp)
    {
        for(int i=0;i<list.size()-1;i++)
        {
            for(int j=i+1;j<list.size();j++)
            {
                if(comp.compare(list.get(i),list.get(j))>0){
                    /*T temp=list.get(i);
                    list.set(i,list.get(j));
                    list.set(j,temp);*/
                	Collections.swap(list, i, j);
                }
            }
        }
    }
}

```
### 2.4.2 工具类-Collections-折半&最值
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
public class Test03 {
	public static void main(String []args)
    {
        List<String> list=new ArrayList<String>();
    
        list.add("abcde");
        list.add("cba");
        list.add("aa");
        list.add("zzz");
        list.add("cba");
        list.add("nbaa");
        System.out.println(list);
    
        //对list集合进行指定顺序的排序。
        mySort(list,new ComparatorByLength());  //先排序再二分
        System.out.println(list);
        
        int index=Collections.binarySearch(list, "aaa");
        System.out.println(index);
        
        //获取最大值
        String max=Collections.max(list,new ComparatorByLength());
        System.out.println("max"+max);
    }
    public static <T>void mySort(List<T> list,Comparator<? super T> comp)
    {
        for(int i=0;i<list.size()-1;i++)
        {
            for(int j=i+1;j<list.size();j++)
            {
                if(comp.compare(list.get(i),list.get(j))>0){
                    /*T temp=list.get(i);
                    list.set(i,list.get(j));
                    list.set(j,temp);*/
                	Collections.swap(list, i, j);
                }
            }
        }
    }
}
### 2.4.3 工具类—Collections-逆序&替换
```
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.TreeSet;
public class Test03 {
	public static void main(String []args)
    {
        
        TreeSet<String>ts=new TreeSet<String>(Collections.reverseOrder(new ComparatorByLength())); //逆序
        
        ts.add("abcde");
        ts.add("cba");
        ts.add("aa");
        ts.add("zzz");
        ts.add("cba");
        ts.add("nbaa");      
        
        System.out.println(ts);
        
        List<String> list=new ArrayList<String>();
        
        list.add("abcde");
        list.add("cba");
        list.add("aa");
        list.add("zzz");
        list.add("cba");
        list.add("nbaa");
        Collections.reverse(list);                     //逆序
        System.out.println(list);
      
        Collections.replaceAll(list, "cba", "nba");  //替换
        System.out.println(list);
    }
}
class ComparatorByLength implements Comparator<String>
{
    public int compare(String o1,String o2)
    {
        int temp=o1.length()-o2.length();
    
        return temp==0?o1.compareTo(o2):temp;
    }
}
```
### 2.4.4 工具类-Collections-其他方法&将非同步
shuffle(List<?> list):使用默认随机源对指定列表进行置换。</br>
shuffle(List<?> list, Random rnd):使用指定的随机源对指定列表进行置换。

给非同步的集合加锁(有点问题)
```
import java.util.List;


class MyCollections{
	public static List synList(List list)
	{
		return new MyList(list);
	}
	
	private abstract class MyList implements List
	{
		private List list;
		
		private static final Object  lock=new Object();
		MyList(List list)
		{
			this.list=list;
		}
			
		public boolean add(Object obj)
		{
			synchronized(lock)
			{
				return list.add(obj);
			}
		}
			
		public boolean remove(Object obj)
		{
			synchronized(lock)
			{
				return list.remove(obj);
			}
		}
	}
}
```
### 2.4.5 工具类-Arrays
public static boolean equals(int[] a,int[]a2):如果两个指定的 int 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。此外，如果两个数组引用都为 null，则认为它们是相等的。
```

public class Test03
{
	public static void main(String[]args)
	{
		
	}
	public static String myToString(int[]a)
	{
		int iMax=a.length-1;
		if(iMax==-1)
			return "[]";
		StringBuffer b=new StringBuffer();
		b.append('[');
		for(int i=0;;i++) {//中间省略了条件判断，提高了效率
			b.append(a[i]);
		if(i==iMax)
			return b.append(']').toString();
		b.append(", ");
		}
	}
}
```
Arrays里面的方法都是静态的
### 2.4.6 工具类-Arrays-asList方法
基于数组的 API 与基于 collection 的 API 之间的桥梁

重点：List asList(数组)将数组转成集合。

好处：其实可以使用集合的方法操作数组中的元素。</br>
注意：数组的长度是固定的，所以对于集合的增删方法是不可以使用的</br>
否则会发生UnsuportedOperationException

1. 如果数组中的元素是对象，那么转成集合时，直接将数组中的元素作为集合中的元素进行集合存储
2. 如果s数组中的元素是基本类型数值，那么会将该数组作为集合中的元素进行存储
```
import java.util.Arrays;
import java.util.List;

//如果数组中的元素是对象，那么转成集合时，直接将数组中的元素作为集合中的元素进行集合存储
//如果s数组中的元素是基本类型数值，那么会将该数组作为集合中的元素进行存储
public class Test03
{
	public static void main(String []args)
	{
		//集合框架的工具类，里面的方法都是静态的。
		
		int []arr= {3,1,5,6,3,6};
		List list=Arrays.asList(arr);
		
		System.out.println(list);   //[[I@c17164]
		
		List<int []>list1=Arrays.asList(arr);
		
		System.out.println(list1);//
	}
}
```
### 2.4.6 工具类-collection-toArray方法
1. toArray():返回包含此 collection 中所有元素的数组。 <T> T[] 
2. toArray(T[] a):返回包含此 collection中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同。 

集合转换成数组？

使用的就是collection接口中的toArray方法。

集合转成数组：可以对集合中的元素操作的方法进行规定，不允许对其增删。
```
import java.util.Arrays;
import java.util.List;

public class Test03
{
	public static void main(String []args)
	{
		//集合框架的工具类，里面的方法都是静态的。
        List<String> list=new ArryList<String>();
        list.add("abc1");
        list.add("abc2");
        list.add("abc3");
        
        String[]arr=list.toArray(new String[5
        ]);//[abc1,abc2,abc3,null,null]
        /** toArray方法需要传入一个指定类型的数值。
        长度该如何定义？
        如果长度小于集合的size，那么该方法会创建一个同类型并和集合相同size的数组。
        如果长度大于集合的size，那么该方法就会使用指定的数组，存储集合中的元素，其他位置默认为null。
        
        所以建议，最后长度就指定为，集合的size
        /
        System.out.println(Arrays.toString(arr));
	}
}
```
toArray方法需要传入一个指定类型的数值。</br>
长度该如何定义？</br>
如果长度小于集合的size，那么该方法会创建一个同类型并和集合相同size的数组。</br>
如果长度大于集合的size，那么该方法就会使用指定的数组，存储集合中的元素，其他位置默认为null。</br>
        
所以建议，最后长度就指定为，集合的size

### 2.4.7 JDK5.0特征——ForEach循环
JDK1.5给Collection接口找了个父接口Iterable：</br>
实现这个接口允许对象成为 “foreach” 语句的目标。

foreach语句：底层还是实现的迭代。</br>
格式：</br>
for(类型 变量： Collection集合|数组)</br>
{</br>
}
```
List<String> list = new ArrayList<String>();
list.add("abc1");
list.add("abc2");
list.add("abc3");
/*
Iterator<String> it = list.iterator();
while(it.hasNext()){
    System.out.println(it.next());
}
*/
foreach(String s:list){
    System.out.println(s);
}
```
**传统for和高级for的区别：**

foreach局限性：
必须有遍历的目标（==数组或Collection单列集合==），一般只用于遍历，不会对元素进行过多的操作。是用来简化书写的。</br>
单列集合(Set)；</br>
双列集合(Map)；

传统for循环相对foreach的优势：
可以定义控制循环的条件和增量。

使用场景：
对数组的遍历如果仅仅是获取数组中的元素，可以使用foerach。
如果要对数组的角标进行操作建议使用传统for。

对于map集合，不能直接使用foreach遍历。但是可以将map转换成单列的set，就可以用了。
```
Map<Integer,String> map=new HashMap<Integer,String>();

map.put(3,"zhangsan");
map.put(1,"wangyi");
map.put(7,"wangwu");
map.put(4,"zhangsansan");

for(Integer key:map.keySet())
{
    String value=map.get(key);
    System.out.println(key+"::"+value);
}

for(map.Entry<Integer,String>me:map.entrySet())
{
    Integer key=me.getKey();
    String value=me.getValue();
    
    System.out.println(key+":"+value);
}
```
### 2.4.8 JDK5.0特征——函数可变参数
函数可变参数。</br>
其实就是一个数组，但是接受的是数组的元素。</br>
自动将这些元素封装成数组，简化了调用者的书写。

注意：可变参数类型，必须定义在参数列表的结尾。
```
public class Test03
{
	public static void main(String[]args)
	{
		int []arr= {5,1,4,7,3};
		int sum= add(arr);
		System.out.println("sum="+sum);
		
		newAdd();//[I@c17164
		
		int sum=newAdd(5,1,4,7,3); //sum=20
		int sum=newAdd(5,1,4,7,3,9,8,7,6);///sum=48
	}
	public static int add(int[]arr)
	{
		int sum=0;
		for(int i=0;i<arr.length;i++)
		{
			sum+=arr[i];
		}
		return sum;
	}
	public static int newAdd(int...   arr)
	{
	   int sum=0;
	   for(int i=0;i<arr.length;i++)
	   {
	       sum+=arr[i];
	   }
	   return sum;
	}
}
``` 
### 2.4.9 JDK5.0特征——静态导入

```
import java.util.ArrayList;
import static java.util.Collections.*;
import static java.lang.System.*;
import java.util.List;
public class Test03
{
	public static void main(String[]args)
	{
		List<String> list=new ArrayList<String>();
		list.add("abc3");
		list.add("abc7");
		list.add("abc1");
		list.add("abc3");
		
		out.println(list);
		
		sort(list);
		
		out.println(list);
		
		String max=max(list);
		
		out.println(max);
	}
}
```
## 2.5 System类
System:类中的方法和属性都是静态的。</br>
常见方法：</br>
System.currentTimeMillis();获取当前时间的毫秒值。</br>
System.getProperties();获取系统的属性信息，并存储到了Properties集合中。</br>
Properties集合中存储和取出的方法来完成元素的操作。
```
import java.util.Properties;
import java.util.Set;

public class Test03
{
    private static final String line_separtor=System.getProperty("line.separator");
	public static void main(String[]args)
	{
		System.out.println("Hello \r\n  World ");//换行
		
		System.out.println("Hello "+System.getProperty("line.separator")+"  World ");//换行
		
		System.out.println("Hello "+line_separtor+"  World ");//换行
		
		System.setProperty("myclasspath","c:\myclass");//增加系统信息
		//给系统设置一些属性信息，这些信息是全局，其他程序都可以使用
		
	}
	public static void demo_1()
	{
		Properties prop=System.getProperties();
		Set<String>nameSet=prop.stringPropertyNames();
		for(String name:nameSet)
		{
			String value=prop.getProperty(name);
			System.out.println(name+"::"+value);
			
		}
	}
}
```
## 2.6 Runtime类
Runtime：没有构造方法摘要，说明该类不可以创建对象。</br>
又发现还有非静态方法，说明该类应该提供静态的返回该类对象的方法。</br>
而且只有一个，说明Runtime类使用了**单例设计模式**</br>
excute:执行。xxx.exe
```
import java.io.IOException;

public class Test03
{
	public static void main(String[]args) throws InterruptedException, IOException
	{
		Runtime r=Runtime.getRuntime();
		/*try {
			r.exec("Notepad.exe C:\\Users\\万上鸿\\Desktop\\day.java");//用Notepad打开day.java
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}*/
		
		Process p=r.exec("Notepad.exe");
		Thread.sleep(5000);
		p.destroy();//杀死子进程
	}
}
```
## 2.7 Math类
Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。

Math:提供了操作数学运算的方式。都是静态的。

常见的方法：</br>
ceil():返回大于参数的最小整数</br>
floor():返回小于参数的最大整数</br>
round():返回四舍五入的整数</br>
pow(a,b):a的b次方。</br>
**random()**:返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。返回值是一个伪随机选择的数，在该范围内（近似）均匀分布。
```
public class Test03
{
	public static void main(String[]args)
	{
		double d1=Math.ceil(12.56);
		double d2=Math.floor(12.56);
		double d3=Math.round(12.56);
		
		System.out.println("d1="+d1);   //13.0
		System.out.println("d2="+d2);  //12.0
		System.out.println("d3="+d3); //13.0
		
		double d=Math.pow(10,2);
		System.out.println(d);
		
		double d=(int)(Math.random()*6+1);
	}
}
```
Random r=new Random();</br>
double d=(int)(d.nextDouble()*6+1);

## 2.8 Date类
在类 Date 所有可以接受或返回年、月、日期、小时、分钟和秒值的方法中，将使用下面的表示形式： 

1. 年份 y 由整数 y - 1900 表示。 
2. 月份由从 0 至 11 的整数表示；0 是一月、1 是二月等等；因此 11 是十二月。 
3. 日期（一月中的某天）按通常方式由整数 1 至 31 表示。 
4. 小时由从 0 至 23 的整数表示。因此，从午夜到 1 a.m. 的时间是 0 点，从中午到 1 p.m. 的时间是 12 点。 
5. 分钟按通常方式由 0 至 59 的整数表示。 
6. 秒由 0 至 61 的整数表示；值 60 和 61只对闰秒发生，尽管那样，也只用在实际正确跟踪闰秒的 Java 实现中。于按当前引入闰秒的方式，两个闰秒在同一分钟内发生是极不可能的，但此规范遵循 ISO C 的日期和时间约定。 

### 2.8.1 日期对象和毫秒值之间的转换

**毫秒值-->日期对象**
1. 通过Date对象的构造方法 new Date(timeMillis);
2. 还可以通过setTime设置</br>
因为可以通过Date对象的方法对该日期中的各个字段（年月日等）进行操作。


**日期对象-->毫秒值**
1. getTime方法</br>
因为可以通过具体的数值进行运算。</br>

**其他方法**：</br>
boolean after(Date when) :测试此日期是否在指定日期之后。</br>
boolean before(Date when):测试此日期是否在指定日期之前。</br> 
int compareTo(Date anotherDate):比较两个日期的顺序。 </br>
```
import java.util.Date;

public class Test03
{
	public static void main(String[]args)
	{
		long time=System.currentTimeMillis();
		System.out.println(time);        //1532611572430
		
		Date date=new Date();
		System.out.println(date);     //Thu Jul 26 21:26:12 CST 2018
		Date date2=new Date(1532611572430L);   //将指定毫秒值封装成Date对象
		
		System.out.println(date2);
	}
}
```
### 2.8.2 日期对象转换成字符串
对日期对象进行格式化。
使用的是DateFormat类中的format方法
```
import java.text.DateFormat;
import java.util.Date;

public class Test03
{
	public static void main(String[]args)
	{
		Date date=new Date();
		
		//获取日期格式对象。具体着默认的风格。FULL LONG等可以指定风格
		DateFormat dateFormat=DateFormat.getDateInstance(DateFormat.FULL);
		//dateFormat=DateFormat.getDateTimeInstance();//2018年7月26日星期四
		
		
		String str_date=dateFormat.format(date);
		
		System.out.println(str_date);//2018年7月26日 下午10:15:11//
	}
}
```
自定义风格

类 SimpleDateFormat</br>
**dateFormat=new SimpleDateFormat("yyyy--MM--dd");**
```
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

public class Test03
{
	public static void main(String[]args)
	{
		Date date=new Date();
		
		//获取日期格式对象。具体着默认的风格。FULL LONG等可以指定风格
		DateFormat dateFormat=DateFormat.getDateInstance(DateFormat.FULL);
		//dateFormat=DateFormat.getDateTimeInstance();//2018年7月26日星期四
		
		dateFormat=new SimpleDateFormat("yyyy--MM--dd");
		
		String str_date=dateFormat.format(date);
		
		System.out.println(str_date);//2018--07--27
	}
}
```
### 2.8.2 将日期格式的字符串转换成日期对象
使用的是DateFormat类中的parse()方法
```
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class Test03
{
	public static void main(String[]args) throws ParseException
	{
		String str_date="2018---07---27";
		
		DateFormat dateFormat=DateFormat.getDateInstance();//注意风格
		
		dateFormat =new SimpleDateFormat("yyyy---MM---dd");
		Date date=dateFormat.parse(str_date);

		System.out.println(date);
	}
}
```

练习
```
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class DateTest {
	public static void main(String[]args) throws ParseException
	{
		String str_day1="2018-07-27";
		String str_day2="2018-01-01";
		
		DateFormat dateFormat=DateFormat.getDateInstance();
		dateFormat=new SimpleDateFormat("yyyy-MM-dd");
		
		Date date1=dateFormat.parse(str_day1);
		Date date2=dateFormat.parse(str_day2);
		
		long time1=date1.getTime();
		long time2=date2.getTime();
		
		long time=Math.abs(time1-time2);
		
		long day=getDay(time);
		
		System.out.println(day);  //207
	}

	private static long getDay(long time) {
		// TODO Auto-generated method stub
		long day=(long)(time/1000/60/60/24);
		return day;
	}
}
```
## 2.9 Calendar类
```
import java.util.Calendar;

public class CalendarDemo {
	public static void main(String[]args)
	{
		Calendar c=Calendar.getInstance();
		
		c.set
		showDate(c);
	}

	public static void showDate(Calendar c) {
		int year=c.get(Calendar.YEAR);
		int month=c.get(Calendar.MONTH)+1;
		int day=c.get(Calendar.DAY_OF_MONTH);
		int week=c.get(Calendar.DAY_OF_WEEK);
		
		System.out.println(year+"年"+month+"月"+day+"日"+getWeek(week));
	}

	private static String getWeek(int i) {
		// TODO Auto-generated method stub
		String []weeks= {"","星期日","星期一","星期二","星期三","星期四","星期五","星期六"};
		return weeks[i];
	}
}
```

练习
```
import java.util.Calendar;

public class CalendarDemo {
	public static void main(String[]args)
	{
		int year=2012;
		
		showDays(year);
	}

	public static void showDays(int year) {
		Calendar c=Calendar.getInstance();
		
		c.set(year, 2, 1);
		
		c.add(Calendar.DAY_OF_MONTH, -1);
		
		showDate(c);
	}

	public static void showDate(Calendar c) {
		int year=c.get(Calendar.YEAR);
		int month=c.get(Calendar.MONTH)+1;
		int day=c.get(Calendar.DAY_OF_MONTH);
		int week=c.get(Calendar.DAY_OF_WEEK);
		
		System.out.println(year+"年"+month+"月"+day+"日"+getWeek(week));
	}

	private static String getWeek(int i) {
		// TODO Auto-generated method stub
		String []weeks= {"","星期日","星期一","星期二","星期三","星期四","星期五","星期六"};
		return weeks[i];
	}
}

```