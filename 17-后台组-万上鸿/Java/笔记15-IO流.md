[toc]
# 5.IO流
## 5.1 IO流概述
IO流用来处理设备之间的数据传输</br>
Java对数据的操作是通过流的方式</br>
Java用于操作流的对象都在IO包中</br>
流按操作数据分为两种:字节流与字符流。
流按流向分为：输入流和输出流

1. IO流用来处理设备之间的数据传输。
   1. 设备：硬盘（速度慢），内存（速度快）
   2. 传输：输入（硬盘（外设）->内存），动作：读</br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp输出（内存->硬盘（外设）），动作:写
2. Java对数据的操作是通过流的方式。
3. Java用于操作流的对象都在IO包中。
4. 流按流向:分为两种：输入流，输出流。</br>
   流按操作的数据类型:分为两种：字节流，字符流。
5. 字符流（后来出现的）：unicode码表的出现，不论什么字符都用两个字符表示，一个中文在不同的码表中表示的不同。所以就将读取数据的字节流和编码表相结合，封装成字符流。就是字节流读取文字字节数据后，不直接操作而是先查指定的编码表，获取对应的文字。
字符流 = 字节流 + 编码表。

1. 字节流的抽象基类(父类)：
   1. InputStream，OutputStream。
2. 字符流的抽象基类(父类)：
   2. Reader,Writer。
3. 注：由这四个类派生出来的子类名称都是以其父类名作为子类名的后缀。
   1. 如：InputStream的子类FileInputStream。
   2. 如：Reader的子类FileReader。</br>

## 5.2 字符流
### 5.2.1  字符流-FileWriter及细节
//需求：将一些文字存储到硬盘一个文件中。</br>
记住：如果要操作文字数据，建议优先考虑字符流。</br>
而且要将数据从内存写到硬盘上，要使用字符流中的输出流。writer</br>
```
import java.io.FileWriter;
import java.io.IOException;

public class Test03 {
	private static final String LINE_SEPARATOR = System.getProperty("line.separator");
	
	public static void main(String[]args) throws IOException {
		
		
		//创建一个可以往文件中写入字符数据的字符输出流对象。
		
		//既然是往一个文件中写入文字数据，那么在创建对象时，就必须明确该文件的位置(即用于存储数据的目的地)
		
		//注意：
        //如果文件不存在，则会自动创建。
        //如果文件存在，则会被覆盖。
		FileWriter fw=new FileWriter("demo.txt");
		
		//调用Writer对象中的writer(string)方法，写入数据。
		
		//其实数据写入到了临时存储缓冲区中，就是写到了输出流中。
		fw.write("abcde");
		
		
		//刷新输出流的缓存区，并立即将缓冲区的数据写到目的文件中
		//fw.flush();
		
		//关闭流，关闭资源。此时如果再写入数据，会抛出异常
		//关闭此流，但要先刷新它。在关闭前会先调用flush刷新缓冲中的数据到目的地。
		fw.close();
		
		//换行：windows:\r\n
        fw.write("\r\nHello");
        fw.write(LINE_SEPARATOR + "World");//LINE_SEPARATOR换行
        
        
        //续写
        //如果append设置为ture，在下一次重新运行写入数据时，文件名相同时，不会覆盖原来的文件，对源文件进行续写。
        FileWriter fw2 = new FileWriter("demo2.txt",true);
        
	}
}


```
换行:\r\n(window)

LINE_SEPRATOR
```
private static final String LINE_SEPRATOR=System.getProperty("line.separator");
```
### 5.2.2 字符流-IO异常处理
简单处理
```
import java.io.FileWriter;
import java.io.IOException;

public class Test03 {
    private static final String LINE_SEPARATOR = System.getProperty("line.separator");

    public static void main(String[] args) {

        FileWriter fw = null;
        try {

            fw = new FileWriter("k:\\demo.txt"); // 异常原因：文件可能不存在，路径错误

            fw.write("Hello"+ LINE_SEPARATOR + "World"); // 异常原因：写到坏道写失败了。

        } catch (IOException e) {
            System.out.println(e.toString());
        } finally {
            if(fw!=null)   //否则会出现空指针异常
            try {
                fw.close(); // 异常原因：关闭底层资源出现异常。
            } catch (IOException e) {
                //code...
                throw new RuntimeException("关闭失败");
            }
        }
    }

}
```
### 5.2.3 字符流-FileReader读取方式
需求：读取一个文本文件。将读取到的字符打印到控制台。</br>
数据要从硬盘读到内存上，要使用字符流中的输入流，Reader。
硬盘的数据基本体现是文件，所以找可以操作文件的Reader的子类，Reader->InputStreamReader->FileReader:用来写入字符文件的便捷类。

两种读取方式：read(), read(char[]):

方法一：
```
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class Test03 {
    private static final String LINE_SEPARATOR = System.getProperty("line.separator");

    public static void main(String[] args) throws IOException {
    	//1,创建读取字符数据的流对象。
    	FileReader fr=new FileReader("demo.txt"); ///如果找不到文件，则抛出异常
    	
    	//用Reader中的read方法读取字符
        int ch =fr.read();
        System.out.println(ch);   //读取一个字符,如果读取到结尾符，则返回-1
    }

}
```
方法二：</br>
频繁读写操作: 创建一个临时容器，用于缓冲读到的字符。就是一个缓冲区。</br>
 char[] ch = new char[BUFFER_SIZE];
```
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class Test03 {
    private static final String LINE_SEPARATOR = System.getProperty("line.separator");

    public static void main(String[] args) throws IOException {
    	FileReader fr=new FileReader("demo.txt"); 
    	
    	//用Reader中的read(char[])读取文本文件数据。
    	char[]buf=new char[3];
    	
    	int num=fr.read(buf);//num为读取的个数
    	
    	System.out.println(new String(buf));
    }

}
```
字符流练习：复制文本文件。
```
import java.io.FileReader;
import java.io.FileWriter;

public class Test03 {

    private static final int BUFFER_SIZE = 1024;

    public static void main(String[] args) {
        long l1 = System.currentTimeMillis();

        System.out.println("正在复制...");
        // 1.读取一个已有的文本文件，使用字符读取流和文件关联。
        FileReader fr = null; // 关闭资源的时候，需要存在关闭的资源

        // 2.创建一个目的，用于存储读到的数据。
        FileWriter fw = null;

        try {
            fr = new FileReader("C:\\practice1.txt");
            fw = new FileWriter("D:\\practice1.txt", true);//缓冲区不够的情况，加true

            // 3.频繁读写操作
            // 创建一个临时容器，用于缓冲读到的字符。就是一个缓冲区。
            char[] ch = new char[BUFFER_SIZE];

            // 定义一个变量记录读取到的字符数，其实就是往数组里装的字符个数
            int len = 0;

            while ((len = fr.read(ch)) != -1) {
                fw.write(ch, 0, len);
                fw.flush();
            }
        } catch (Exception e) {
                //暂时不处理
                new RuntimeException("读写失败！");
        } finally {

            // 4.关闭流资源。 （文件流没有关闭时，表示文件正在执行时，是删除不掉的）
            if (fr != null)
                try {
                    fr.close();
                } catch (Exception e) {
                    //直接抛出，以后图形化界面代替

                }

            if (fw != null)
                try {
                    fw.close();
                } catch (Exception e) {
                    //直接抛出
                }
        }

        long l2 = System.currentTimeMillis();
        System.out.println("复制成功！耗时：" + (l2 - l1) + "毫秒");

    }

}
```
### 5.2.4 字符流——缓冲区——BufferedWriter
字符流的缓冲区：Java自己封装的缓冲区对象。

char[] ch = new char[BUFFER_SIZE];//这个也是缓冲区
```
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class Test03 {
	private static final String LINE_SEPARATOR = System.getProperty("line.separator");
	
    public static void main(String[] args) throws IOException {
        FileWriter fw=new FileWriter("buf.txt");
        
        //为了提高写入的效率。使用了字符流的缓冲区。
        //创建了一个字符写入流的缓冲区对象，并和指定要被缓冲的流对象相关联。
        BufferedWriter bufw = new BufferedWriter(fw);
        
        //使用缓存区的写入方法将数据先写入到缓存区中。
        bufw.write("abcdefg"+LINE_SEPARATOR+"rgageabbebe");
        
        bufw.newLine();         //写入一个换行符
        
        //使用缓冲区的刷新方法将数据刷到目的地中。
        bufw.flush();

        //关闭缓冲区
        bufw.close();//内部是将流关闭
    }
}
```
### 5.2.4 字符流——缓冲区——BufferedReader
字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。
```
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class Test03 {
	private static final String LINE_SEPARATOR = System.getProperty("line.separator");
	
    public static void main(String[] args) throws IOException {
       FileReader fr=new FileReader("buf.txt");
       
       //字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。 
       BufferedReader bufr=new BufferedReader(fr);
       
       String line=null;
       while((line=bufr.readLine())!=null)
       {
    	   System.out.println(line);
       }
    }
}
```
字符流缓冲区：
BufferedWriter:newLine();

BufferedReader:readLine();

### 5.2.5 字符流——缓冲区——BufferedReader-readLine()原理
FileReader fr=new FileReader("buf.txt");</br>
BufferReader bufr=new BufferReader();</br>
buft.read():这个read是从缓冲区中取出的字符数据。所以覆盖了父类中的read方法。</br>
其实到这步就可以操作从缓冲区读取到的字符了，根据文本的行特点，可以按照行读取，所以进行了下一步的动作有了一个新的方法。readLine()</br>
readLine():使用了读取缓冲区的read方法，将取到的字符进行缓冲并判断换行标记。将标记前的缓存数据变成字符串返回。
### 5.2.5 字符流——缓冲区——复制文本文件
```
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class Test03 {
	private static final String LINE_SEPARATOR = System.getProperty("line.separator");
	
    public static void main(String[] args) throws IOException {
    	FileReader fr=new FileReader("buf.txt");
    	BufferedReader bufr=new BufferedReader(fr);
        
    	FileWriter fw=new FileWriter("buf_copyt.txt");
        BufferedWriter bufw=new BufferedWriter(fw);
        
        String line=null;
        while((line=bufr.readLine())!=null)
        {
        	bufw.write(line);
        }
        /**
        int ch=0;
        while((ch=bufr.read())!=-1)
        {
        	bufw.write(ch);
        	bufw.newLine(line);
        	bufw.flush();
        }
        
        bufr.close();
        bufw.close();
        */
    }
}
```
### 5.2.5 字符流——缓冲区——自定义MyBufferedReader-read方法&readLine方法
```
import java.io.FileReader;
import java.io.IOException;

/**
 * 自定义的读取缓冲区。其实是模拟一个BufferedReader
 * 
 * @author 万上鸿
 * 分析：
 * 缓冲区中无非就是封装了一个数组，
 * 并对外提供了更多的都是数组进行访问。
 * 其实这些方法最终操作都是数组的角标。
 * 
 * 缓冲的原理：
 * 其实就是从源中获取一批数据装进缓冲区中。
 * 再从缓冲区中不断的取出一个一个数据。
 * 
 * 但此次取完后，再从源中继续取一批数据进缓冲区。
 * 当源中的数据取光时，用-1作为结束标志。
 * */
public class MyBufferedReader {
	private FileReader r;
	
	//定义一个数组作为缓冲区
	private char[] buf=new char[1024];
	
	//定义一个指针用于操作这个数组中的元素。当操作当最后一个元素后，指针应该归0。
	private int pos=0;
	
	//定义一个计数器用于记录缓冲区的数据个数。当该数据减到0，就从源中继续获取数据到缓冲区。
	private int count=0;
	
	MyBufferedReader(FileReader r)
	{
		this.r=r;
	}
	
	public int myRead() throws IOException
	{
		if(count==0)
		{
			count=r.read(buf);
			pos=0;
		}
		if(count<0)
			return -1;
		
		char ch=buf[pos++];
		
		count--;
		return ch;
		
		/**
		//1.从源中获取一批数据到缓冲区中.需要先做判断，只有计数器为0时，才需要从源中获取数据。
		if(count==0) {
			count=r.read(buf);
			if(count<0)
				return -1;
			//每次获取数据到缓冲区后，角标归零
			pos=0;
			char ch=buf[pos];
			pos++;
			count--;
			
			return ch;
		}else if(count>0)
		{
			char ch=buf[pos];
			
			pos++;
			count--;
			
			return ch;
		}
		*/
	}
	
	public String myReadLine() throws IOException
	{
		StringBuilder sb=new StringBuilder();
		
		int ch=0;
		while((ch=myRead())!=-1) {
			
			if(ch=='\r')
				continue;
			if(ch=='\n')
				return sb.toString();
			//将从缓冲区中读到的字符，存储到缓存的缓冲区中。
			sb.append(ch);
		}
		return null;
	}
}
```

### 5.2.5 字符流—缓冲区—装饰设计模式和继承
```

public class PersonDemo {

    public static void main(String[] args) {
        Person p = new Person();
        NewPerson np = new NewPerson(p);

        np.chifan();
    }

}

class Person {
    void chifan() {
        System.out.println("吃饭");
    }
}

//装饰设计模式： 这个类的出现是为了增强Person而出现的
class NewPerson {
    private Person p;

    NewPerson(Person p) {
        this.p = p;
    }

    void chifan() { // 对Person类的chifan方法进行增强。
        System.out.println("开胃酒");
        p.chifan();
        System.out.println("甜点");
    }
}

//继承实现：
class NewPerson2 extends Person {

    void chifan() {
        System.out.println("开胃酒");
        super.chifan();
        System.out.println("甜点");
    }
}
```

**区别**

首先有一个继承体系。</br>
Writer
1. |--TextWriter：用于操作文本
   1. |--BufferTextWriter：加入了缓冲技术的操作文本的对象。
2. |--MediaWriter：用于操作媒体。
   1. |--BufferMediaWriter:

那这里就OK了。但这样做好像并不理想。</br>
如果这个体系进行功能扩展，有多了流对象。</br>
那么这个流要提高效率，是不是也要产生子类呢？是。整数就会发现只为了提高功能，进行的继承，</br>
导致继承体系越来越臃肿。不够灵活。

重新思考这个问题？</br>
既然加入的都是同一种技术--缓冲。</br>
前一种是让缓冲和具体的对象相结合。</br>
可不可以将缓冲进行单独的封装，哪个对象需要缓冲就将哪个对象和缓冲关联</br>

```
class Buffer
{
    Buffer(TextWriter w)
    {
        
    }
    Buffer(MediaWriter w)
    {
        
    }
}
```
```
class BufferWriter extends Writer
{
    BufferWriter(Writer w)
    {
        
    }
}
```
Writer
1. |--TextWriter：用于操作文本
2. |--MediaWriter：用于操作媒体。
3. |--BufferWriter:用于提高效率

装饰比继承灵活。

特点：装饰类和被装饰类都必须所属同一个接口或者父类。
## 5.3 字节流
字节流的抽象基类：</br>
java.io.InputStream(输入流)</br>
java.io.OutputStream(输出流)</br>

1.基本操作与字符流相同。</br>
2.不仅可以操作字符，还可以操作其他媒体文件。</br>
### 5.3.1 字节流—缓冲区—操作文件基本演示
```
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class Test03
{
	public static void main(String[]args) throws IOException
	{
		demo_write();
		
		demo_read();
	}

	private static void demo_read() throws IOException {
		// TODO Auto-generated method stub
		//1.创建一个读取流对象。和指定文件关联
		FileInputStream fis=new FileInputStream("bytedemo.txt");
		
		//System.out.println(fis.available());//输出的是字节个数
		
		byte []buf=new byte[fis.available()];
		fis.read(buf);
		
		
		//建议使用这种读取数据的方式
		/*byte[] buf=new byte[1024];
		
		int len=0;
		
		while((len=fis.read(buf))!=-1)
		{
			System.out.println(new String(buf,0,len));
		}
		
		int ch=0;
		while((ch=fis.read())!=-1)
		{
			System.out.println((char)ch);
		}*/
	}

	private static void demo_write() throws IOException {
		// TODO Auto-generated method stub
		//1.创建字节输出流对象。用于操作文件。
		FileOutputStream fos=new FileOutputStream("bytedemo.txt");
		
		//2.写数据,直接写入到了目的地中
		fos.write("abcdefg".getBytes());
		
		fos.close();//关闭资源的动作要完成
		
	}
	
}
```
### 5.3.2 字节流—练习-Mp3
```
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class Test03
{
	public static void main(String[]args) throws IOException
	{
		copy_1();
		
		copy_2();
		
		copy_3();
		
		copy_4();
	}

	//千万不要用，效率非常低
	private static void copy_4() throws IOException {
		// TODO Auto-generated method stub
		FileInputStream fis=new FileInputStream("c:\\0.mp3");
		FileOutputStream fos=new FileOutputStream("c:\\4.mp3");
		
		int ch=0;
		while((ch=fis.read())!=-1)
		{
			fos.write(ch);
		}
		
		fos.close();
		fis.close();
	}

	//不建议
	private static void copy_3() throws IOException {
		// TODO Auto-generated method stub
		FileInputStream fis=new FileInputStream("c:\\0.mp3");
		FileOutputStream fos=new FileOutputStream("c:\\1.mp3");
		
		byte[]buf=new byte[fis.available()];
		
		fis.read(buf);
		fos.write(buf);
		
		fos.close();
		fis.close();
	}

	private static void copy_2() throws IOException {
		// TODO Auto-generated method stub
		FileInputStream fis=new FileInputStream("c:\\0.mp3");
		BufferedInputStream bufis=new BufferedInputStream(fis);
		
		FileOutputStream fos=new FileOutputStream("c:\\2.mp3");
		BufferedOutputStream bufos=new BufferedOutputStream(fos);
		
		byte[]buf=new byte[1024];
		
		int len=0;
		
		while((len=bufis.read(buf))!=-1)
		{
			bufos.write(buf,0,len);
			bufos.flush();     //缓冲区需要刷新
		}
		
		bufos.close();
		bufis.close();
	}

	private static void copy_1() throws IOException {
		// TODO Auto-generated method stub
		FileInputStream fis=new FileInputStream("c:\\0.mp3");
		FileOutputStream fos=new FileOutputStream("c:\\1.mp3");
		
		byte[]buf=new byte[1024];
		
		int len=0;
		
		while((len=fis.read(buf))!=-1)
		{
			fos.write(buf,0,len);
		}
		
		fos.close();
		fis.close();
	}

}
```
## 5.4 键盘录入
### 5.4.1 键盘录入演示
键盘本身就是一个标准的输入设备。</br>
对于java而言，对于这种输入设备都有对应的对象

注意：默认的输入设备和默认的输出设备，不需要关，会随着系统的关闭而关闭
```
import java.io.IOException;
import java.io.InputStream;

public class ReadKey {
	public static void main(String[]args) throws IOException
	{
		readKey();
	}

	private static void readKey() throws IOException {
		// TODO Auto-generated method stub
		InputStream in=System.in;
		
		int ch=in.read();//阻塞式方法
		System.out.println(ch);
		
		//in.close();//默认的输入设备和默认的输出设备，不需要关，会随着系统的关闭而关闭
	}
}

```
### 5.4.2 读取键盘录入
获取用户键盘录入的数据</br> 并将数据变成大写显示再控制台上。</br> 如果用户输入的是over，则结束键盘录入</br>

思路:
1. 因为键盘录入只读取一个字节，要判断是否是ove    r，需要将读取的字节转换成字符串。 
2. 那就需要一个容器。StringBuilder 
3. 在用户回车之前，将录入的数据转换成字符串判断即可。
```
import java.io.IOException;
import java.io.InputStream;

public class TransStreamDemo {
	public static void main(String[]args) throws IOException {
		//1.创建容器。
		StringBuilder sb=new StringBuilder();
		
		//2.获取键盘读取流
		InputStream in =System.in;
		
		//3.定义变量记录读取到的字节，并循环获取。
		int ch=0;
		while((ch=in.read())!=-1)
		{
			//在判断之前需要判断是否是换行标记，因为换行标记不存储。
			if(ch=='\r')
				continue;
			if(ch=='\n') {
				String temp=sb.toString();
				if("over".equals(temp))
						break;
				System.out.println(temp.toUpperCase());
				sb.delete(0, sb.length());
			}
				
			//将读取到的字符存储到StringBuilder中
			sb.append(ch);
			
			System.out.println(ch);
		}
	}
}
```
## 5.4 转换流
### 5.4.1 转换流-键盘录入-读取演示：InputStreamReader
字节流——>字节流
```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

public class TransStreamDemo {
	public static void main(String[]args) throws IOException {
		
		//字节流。
		InputStream in=System.in;//对中文读两次，将字符编码为字节
		
		//将字节转成字符的桥梁。转换流
		InputStreamReader isr=new     InputStreamReader(in); //in转换成字符流。将字节流in的字节读取，查表解码，转成字符。
		//这时对中文一步读取，先读两个字节，然后查表解码成字符。
		
		//字符流。
		BufferedReader bufr=new BufferedReader(isr);//字符装饰类只能装饰字符流
		
		String Line=null;
		
		while((Line=bufr.readLine())!=null)
		{
			if("over".equals(Line))
				break;
			System.out.println(Line.toUpperCase());
		}
	}
}

```

### 5.4.12 转换流-写入演示：OutputStreamWriter
```
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;

public class TransStreamDemo {
	public static void main(String[]args) throws IOException {
		
		//字节流。
		InputStream in=System.in;//对中文读两次，将字符编码为字节
		
		//将字节转成字符的桥梁。转换流
		InputStreamReader isr=new InputStreamReader(in);
		//in转换成字符流。将字节流in编码的字节读取，查表，转成字符。这时对中文一次性解码，先读两个字节，然后查表变成字符。
		
		//字符流。
		BufferedReader bufr=new BufferedReader(isr);//字符装饰类只能装饰字符流
		
		//字节流
		OutputStream out=System.out;
		
		OutputStreamWriter osw=new OutputStreamWriter(out);//字节流out转字符流。来接收字符流的数据。方向是由下往上
		
		BufferedWriter bufw=new BufferedWriter(osw);
		//为了实现和System.out.println(line.toUpperCase()); 一样的效果，
        //这里使用修饰类BufferedWriter的newLine()方法，使用缓冲区也提高了效率。
        //或者直接加上"\r\n"
		String Line=null;
		
		while((Line=bufr.readLine())!=null)
		{
			if("over".equals(Line))
				break;
			//System.out.println(Line.toUpperCase());
			
			/*osw.write(Line.toUpperCase()+"\r\n");
			osw.flush();*/
			
			bufw.write(Line.toUpperCase());
			//将字符编码为字节传给缓冲区。
            //目的地是转换流osw。然后给字节流out,输出到控制台
			
			bufw.newLine();
			bufw.flush();//字符流需要手动刷新
		}
	}
}

```

简化：
```
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;

public class TransStreamDemo {
	public static void main(String[]args) throws IOException {
		
		//键盘录入
		BufferedReader bufr=new BufferedReader(new InputStreamReader(System.in);
		
		//输出
		BufferedWriter bufw=new BufferedWriter(new OutputStreamWriter(System.out));
		
		String Line=null;
		
		while((Line=bufr.readLine())!=null)
		{
			if("over".equals(Line))
				break;
			//System.out.println(Line.toUpperCase());
			
			/*osw.write(Line.toUpperCase()+"\r\n");
			osw.flush();*/
			
			bufw.write(Line.toUpperCase());
			bufw.newLine();
			bufw.flush();
		}
	}
}

```
### 5.4.3 转换流-需求演示
1. 需求：将键盘录入的数据写入到一个文件当中
```
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

public class TransStreamDemo {
	public static void main(String[]args) throws IOException {
		
		//键盘录入
		BufferedReader bufr=new BufferedReader(new InputStreamReader(System.in));
		
		//输出
		BufferedWriter bufw=new BufferedWriter(new OutputStreamWriter(new FileOutputStream("a.txt")));
		
		String Line=null;
		
		while((Line=bufr.readLine())!=null)
		{
			if("over".equals(Line))
				break;
			//System.out.println(Line.toUpperCase());
			
			/*osw.write(Line.toUpperCase()+"\r\n");
			osw.flush();*/
			
			bufw.write(Line.toUpperCase());
			bufw.newLine();
			bufw.flush();
		}
	}
}
```
2. 需求：将一个文本文件显示在控制台上。
```
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

public class TransStreamDemo {
	public static void main(String[]args) throws IOException {
		
	
		BufferedReader bufr=new BufferedReader(new InputStreamReader(new FileInputStream("a.txt")));
		
		
		BufferedWriter bufw=new BufferedWriter(new OutputStreamWriter(System.out));
		
		String Line=null;
		
		while((Line=bufr.readLine())!=null)
		{
			if("over".equals(Line))
				break;
			//System.out.println(Line.toUpperCase());
			
			/*osw.write(Line.toUpperCase()+"\r\n");
			osw.flush();*/
			
			bufw.write(Line.toUpperCase());
			bufw.newLine();
			bufw.flush();
		}
	}
}
```
3.需求：将一个文本文件的内容追加到另一个文本文件当中。
```
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

public class TransStreamDemo {
	public static void main(String[]args) throws IOException {
		
	
		BufferedReader bufr=new BufferedReader(new InputStreamReader(new FileInputStream("a.txt")));
		
		
		BufferedWriter bufw=new BufferedWriter(new OutputStreamWriter(new FileOutputStream("b.txt")));
		
		String Line=null;
		
		while((Line=bufr.readLine())!=null)
		{
			if("over".equals(Line))
				break;
			//System.out.println(Line.toUpperCase());
			
			/*osw.write(Line.toUpperCase()+"\r\n");
			osw.flush();*/
			
			bufw.write(Line.toUpperCase());
			bufw.newLine();
			bufw.flush();
		}
	}
}
```
### 5.4.3 流的操作基本规律

InputStreamReader 是用来读取原始字节流，可指定编码格式，而FileReader是读取字符流，使用系统默认的编码格式，当读取中文文件是易出现乱码问题。

转换流：
1. InputStreamReader：字节到字符的桥梁，解码
2. OutputStreamReader:字符到字节的桥梁，编码

流的操作基本规律：</br>
之所以要弄清楚这些规律，是因为流对象太多，开发时不知道用哪个对象合适。</br>

1. 明确源和目的（汇）。</br>
   1. 源：InputStream , Reader 两个体系
   2. 目的：OutputStream , Writer 两个体系
2. 明确数据是否是纯文本数据。
   1. 源：是纯文本：Reader</br>
         &emsp; &emsp;不是： InputStream
   2. 汇：是纯文本：Writer</br>
         &emsp;&emsp;不是： OutputStream

到这里，就可以明确需求中具体要使用哪个体系。<
3. 明确具体的设备。</br>
   1. 源设备：</br>
        &emsp;硬盘：File</br>
        &emsp;键盘：System.in</br>
        &emsp;内存：数组</br>
        &emsp;网络：Socket流</br>
   2. 目的设备：</br>
        &emsp;硬盘：File</br>
        &emsp;控制台：System.out</br>
        &emsp;内存：数组</br>
        &emsp;网络：Socket流</br>

到这里，就可以明确需求中具体要使用哪个体系的哪个对象。</br>
4.是否需要其他额外功能。
   1. 是否需要高效（缓冲区）：是，就加上buffer.</br>
   2. 转换。

### 5.4.4 流的操作基本规律-需求
**需求1：复制一个文本文件。**</br>
1. 明确源和目的:
   1. 源：InputStream, Reader
   2. 目的：OuputStream, Writer
2. 确数据是否是纯文本数据:
   1. 源：是，Reader
   2. 目的：是，Writer
3. 明确具体的设备:
   1. 源：硬盘，File
   2. 目的：硬盘，File
```
FileReader fr = new FileReader("a.txt");
FileWriter fw = new FileWriter("a_copy.txt");       
```
4. 是否需要其他额外功能：
   1. 是否需要高效：
       1. 源：需要，Buffer
       2. 目的：需要，Buffer
```
BufferedReader bufr = new BufferedReader(new FileReader("a.txt"));
BufferedWriter bufr = new BufferedWriter(new FileWriter("a_copy.txt"));
```
**需求2：读取键盘的录入信息，并写入到一个文件中。**
1. 明确源和目的:
   1. 源：InputStream, Reader
   2. 目的：OuputStream, Writer
2. 确数据是否是纯文本数据:
   1. 源：是，Reader
   2. 目的：是，Writer
3. 明确具体的设备:
   1. 源：键盘 System.in
   2. 目的：硬盘，File
```
InputStream in = System.in;
FileWriter fw = new FileWriter("a.txt");
```
这样可以完成，但是麻烦。将读取的字节数据转成字符串，再由字符流操作。

4. 额外功能。
   1. 转换。
      1. 源：需要，将字节流转换成字符流。因为明确的源是Reader,这样操作文本数据更便捷。InputStreamReader </br>
        目的：不需要
        `InputStreamReader isr = new InputStreamReader(System.in);`
        `FileWriter fw = new FileWriter("a.txt");`
      2. 高效。
            源：需要，Buffer
            目的：需要，Buffer

            BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));
            BufferedWriter bufw = new BufferedWriter(new FileWriter("a.txt"));


**需求3：将一个文本文件数据显示在控制台上。**
1. 明确源和目的:
   1. 源：InputStream, Reader
   2. 目的：OuputStream, Writer
2. 确数据是否是纯文本数据:
   1. 源：是，Reader
   2. 目的：是，Writer
3. 明确具体的设备:
   1. 源：硬盘，File
   2. 目的：控制台 System.out
```
FileReader fr =new FileReader("a.txt"); 
OutputStream out=System.out
```
这样可以完成，但是麻烦。将读取的字节数据转成字符串，再由字符流操作。

4. 额外功能。
   1. 转换。
      1. 源：需要，将字节流转换成字符流。因为明确的源是Reader,这样操作文本数据更便捷。InputStreamReader </br>
        目的：不需要
        `FileReader fr =new FileReader("a.txt");`
        `OutputStreamWriter ouut=new OutputStreamWriter(System.out);`
      2. 高效。
            源：需要，Buffer
            目的：需要，Buffer

            BufferedReader bufr = new BufferedReader(new FileReader("a.txt"));</br>
            BufferedWriter bufw = new BufferedWriter(new OutputSreeamWriter(System.out));</br>
            //System.out.println(line);


**需求4：读取键盘录入数据，显示在控制台上。**
  1. 明确源和目的:
   1. 源：InputStream, Reader
   2. 目的：OuputStream, Writer
2. 确数据是否是纯文本数据:
   1. 源：是，Reader
   2. 目的：是，Writer
3. 明确具体的设备:
   1. 源：键盘：System.in
   2. 目的：控制台:System.out
```
InputStream in=System.in
OutputStream out=System.out
```
4. 是否需要其他额外功能：
   1. 是否需要高效：
       1. 源：需要，Buffer
       2. 目的：需要，Buffer

            BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));</br>
            BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));
### 5.4.5 转换流的编码解码
**需求：将一个中文字符串数据按照指定的编码表写入到一个文本文件中。**
1. 目的：OutputStream Writer
2. 是纯文本，Writer
3. 设备：硬盘 File
`FileWriter fw=new FileWriter("a.txt");`
fw.write("你好");
```
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.OutputStreamWriter;

public class TransStreamDemo03 {
	public static void main(String[]args) throws IOException
	{
		writeText_1();
	}

	private static void writeText_1() throws IOException {
		// TODO Auto-generated method stub
		OutputStreamWriter osw=new OutputStreamWriter(new FileOutputStream("gbk_1.txt"),"gbk");
		
		FileWriter fw=new FileWriter("gbk_1.txt");
		
		/*这两句话的功能是等同的
		FileWriter:确实是转换流指定了本机默认码表的体现。而且这个转换流的子类对象，可以方便操作文件。
		            简单来说：操作文件的字节流+本机默认的编码表
		            这是按照默认码表来操作表示操作文件的便捷类。
		如果操作文本文件需要明确具体的编码。FileWriter就不行了。必须用转换流
		*/
		osw.write("你好");
		
		osw.close();
	}
}
```
注意：居然需求中已经明确了指定编码表的动作。</br>
那就不可以使用FileWriter，因为FileWriter内部是使用默认的本地码表。</br>
只能使用其父类。OutputStreamWriter。</br>
OutputStreamWriter接收一个输出流对象，既然是操作文件，那么该对象应该是FileOutputStream</br>
OutputStreamWriter osw=new OutputStreamWriter(("a.txt"),charsetName);

什么时候使用转换流呢？
1. 源或者目的地设备是字节流，但是操作的却是文本数据，可以转换作为桥梁。提高对文本操作的便捷。
2. 一旦操作文本涉及到具体的指定编码表时，必须使用转换流。
## 5.5 File类
### 5.5.1 File对象—构造函数&字段
```
import java.io.File;

public class FileDemo {
	public static void main(String[]args) {
		constructorDemo();
	}

	private static void constructorDemo() {
		// TODO Auto-generated method stub
		//可以将一个已存在的，或者不存在的文件或者目录封装成file对象。
		File f1=new File("a.txt");
		
		File f2 = new File("C:\\a.txt");
		
		File f=new File("c:\\");
		
		File f3=new File(f,"a.txt");
		
		File f4=new File("c:"+File.separator+"abc"+File.separator+"a.txt");
		System.out.println(f4);
	}
}
```
### 5.5.1 File对象—基本功能
1. 获取：
   1. 获取文件名称</br>
   **String getName()**:返回由此抽象路径名表示的文件或目录的名称。 
   2. 获取文件路径</br>
    **String getPath()**:给什么路径获得什么路径将此抽象路径名转换为一个路径名字符串。</br> String getAbsolutePath():返回此抽象路径名的绝对路径名字符串。</br> 
    File getAbsoluteFile():获得绝对路径的File对象返回此抽象路径名的绝对路径名形式。 
   3. 获取文件大小</br>
    **long length()**:返回由此抽象路径名表示的文件的长度。 
   4. 获取文件的修改时间</br>
    **long lastModified()**:返回此抽象路径名表示的文件最后一次被修改的时间。 
2. 创建与删除：
   1. 创建</br>
    **boolean createNewFile()**:当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。 </br>
    **static File createTempFile(String prefix, String suffix)**:在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。</br>
    **static File createTempFile(String prefix, String suffix, File directory)**:在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名 称 。</br>
   2. 文件夹的创建：</br>
    **boolean mkdir()**:创建此抽象路径名指定的目录。</br>
    **boolean mkdirs()**:delete删除时，删除的是最后一个文件夹创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。
   3. 删除</br>
    **boolean delete()**:删除此抽象路径名表示的文件或目录。 </br>
    ①如果文件正在被流操作，文件删除不了。</br>
    ②如果目录内有内容，目录删不了。</br>
    ③删除了不经过回收站。</br></br>
    **void deleteOnExit()**  </br>   //告诉虚拟机在退出时删除</br>
    在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。 
3. 判断：
   1. 存在： </br>
    **boolean exists()**:测试此抽象路径名表示的文件或目录是否存在。 </br>
    绝对路径： **boolean isAbsolute()**:测试此抽象路径名是否为绝对路径名。</br> 
    目录：**boolean isDirectory()**:测试此抽象路径名表示的文件是否是一个目录。</br> 文件：**boolean isFile()**:测试此抽象路径名表示的文件是否是一个标准文件。</br>
    隐藏：**boolean isHidden()**:系统级隐藏文件的判断方式不一样，这里不考虑过滤系统级隐藏文件测试此抽象路径名指定的文件是否是一个隐藏文件。</br>            
    可执行：**boolean canExecute()**:测试应用程序是否可以执行此抽象路径名表示的文件。</br>  
    可读：**boolean canRead()**:测试应用程序是否可以读取此抽象路径名表示的文件。</br> 
    可写：**boolean canWrite()**:测试应用程序是否可以修改此抽象路径名表示的文件。</br>
4. 重命名：**boolean renameTo(File dest)**:如果被重命名文件不存在，重命名失败，返回false,重新命名此抽象路径名表示的文件。</br>   
   **File dest**的作用：确定重命名的名字和重命名后文件的位置。如果位置变化了，原来的文件会被删除，即剪切的意思。
5. 盘空间操作：</br>
    文件系统根（盘符）：**static File[] listRoots()**:因为盘符名是路径，所以getName获取的为空字符串。可以通过getPath获得抽象路径。列出可用的文件系统根。 </br>
    分区大小：**long getTotalSpace()**:返回此抽象路径名指定的分区大小。</br>
    分区可用空间大小（常用）:**long getFreeSpace()**:返回此抽象路径名指定的分区中未分配的字节数。</br>
    分区可用于虚拟机的空间大小：**long getUsableSpace()**:返回此抽象路径名指定的分区上可用于此虚拟机的字节数。</br>
6. 获取目录内容：</br>
    注意：
   1. ①如果File对象里的路径不是目录或者是系统级目录（如各盘的隐藏的系统信息卷标目录等），就是会返回null，然后使用时报空指针异常，数组就没有创建成功。
   2. ②如果是空目录，则数组存在，但是长度为0，遍历时输出的是数组的地址。</br>
    获取目录下的文件和目录（包括隐藏的）：</br>**String[] list()**:返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。
    获取目录下的文件和目录 的 File对象：</br>**File[] listFiles()** :可以使用getPath获取抽象路径,通过getName获得文件名称返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。
7. 带过滤器：</br>
**String[] list(FilenameFilter filter)**:</br>文件名过滤器。数组中存放的是getName()的文件名。返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。</br> 
**File[] listFiles(FileFilter filter)**:</br>文件过滤器。数组中存放的是getpath()的路径。返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。</br>**File[] listFiles(FilenameFilter filter)** :</br>这个方法可以在文件过滤器中通过getName实现文件名的获取。用第二个方法代替。返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。 
```
import java.io.File;
import java.io.FileFilter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class FileMethodDemo {

    public static void main(String[] args) throws IOException {


//      getDemo();
//      createAndDeleteDmoe();
//      isDemo();
//      renameToDemo();
//      listRootsDemo();
//      panDemo();
        listDemo();

    }



//获取：

        public static void getDemo() throws IOException{
            File file = new File("D:\\Workspaces\\MyEclipse Professional 2014\\IO\\utf8_1.txt");

            String name = file.getName();  //文件名

            String absPath = file.getAbsolutePath(); //获得所给路径的 绝对路径
//          File absPathFile = file.getAbsoluteFile(); //返回绝对路径的File对象


            String Path = file.getPath();//获得指定的路径（相对或者绝对看指定的是什么路径）
            String parentPath = file.getParent();  //父目录，在给出的是绝对路径时返回父目录路径，否者返回null

            long len = file.length();  //文件大小

            long time = file.lastModified();  //修改时间：作用，通过另一个线程监控判断 修改时间是否改变，从而可以对文件进行自动刷新的操作。

            System.out.println("name:\t\t" + name);
            System.out.println("absPath:\t" + absPath);
            System.out.println("Path:\t\t" + Path);
            System.out.println("parPath:\t" + parentPath);
            System.out.println("len:\t\t" + len);
            System.out.println("time:\t\t" + new SimpleDateFormat("yyyy/MM/dd H:m:s").format(new Date(time)));
        }


//文件和目录 创建和删除：      

        public static void createAndDeleteDmoe() throws IOException{
            File file = new File("abc.txt");

//文件的删除和创建：

            /*
                    和输出流不一样，如果文件不存在，则创建，如果文件存在，则不创建。
                    （当然输出流可以在构造函数中定义追加模式，不覆盖）            
             */
            boolean b = file.createNewFile();  //如果文件存在，就不创建，返回false
            System.out.println("b = " + b);

            boolean c = file.delete(); //文件不存在时，返回false
            System.out.println("c = " + c);

//文件夹的删除和创建：

            File file1 = new File("abc");
            boolean d = file1.mkdir();   //文件夹存在时，返回false
            System.out.println("d = " + d);
            file1.delete();

            File file2 = new File("ABC\\abc");  //创建多级目录
            file2.mkdirs();   //文件目录存在时，返回false
            file2.delete();    //删除时，删除的是最后一个文件夹


        }


//判断：
        public static void isDemo(){
            File f = new File("demo12.txt");

            boolean b = f.exists();  //是否存在，如果文件不存在，下面的全都是flase。
                                                            //所在执行其他判断操作时，应先判断文件是否存在。
            System.out.println("b = "+ b);

            boolean c = f.isAbsolute();  //是否是绝对路径
            System.out.println("c = "+ c);

            boolean d = f.isDirectory();  //是否是目录
            System.out.println("d = "+ d);

            boolean e = f.isFile();  //是否是文件
            System.out.println("e = "+ e);

            boolean a = f.isHidden();  //是否隐藏
            System.out.println("a = "+ a);

            boolean  b1= f.canExecute();  //是否能执行
            System.out.println("b1 = "+ b1);

            boolean b2 = f.canRead();  //是否可读
            System.out.println("b2 = "+ b2);

            boolean b3 = f.canWrite();  //是否可写
            System.out.println("b3 = "+ b3);    

        }

//重命名：
        public static void renameToDemo() throws IOException{
            File f1 = new File("D:\\demo1.mp3");
//          File f2 = new File("D:\\demo2.mp3");

            boolean b = f1.renameTo(new File("D:\\demo2.mp3"));
            System.out.println("b = " + b);

        }


//列出系统根
        public static void listRootsDemo(){
            File[] fileArr = File.listRoots();

            for(File f :fileArr){
                System.out.println(f); 
/*  显示：
                C:\
                D:\
                E:\
                H:\
*/
            }
        }


//盘符空间操作：

        private static void panDemo() {
                File f = new File("D:\\");
                //磁盘空间操作：总大小，剩余可用空间。
                System.out.println("getTotalSpace:"+ new DecimalFormat("0.000").format(f.getTotalSpace()/1024.0/1024.0/1024.0) + "G"); //分区大小
                System.out.println("getFreeSpace：" + new DecimalFormat("0.000").format(f.getFreeSpace()/1024.0/1024.0/1024.0) + "G");//分区可用空间
                System.out.println("getUsableSpace:"+new DecimalFormat("0.000").format(f.getUsableSpace()/1024.0/1024.0/1024.0) + "G");//分区可用于虚拟机的空间大小

        //找出剩余空间最大的盘：数组法比较合理

                //①数组法：

                File[] fileArr = File.listRoots();
                Long[] longArr = new Long[fileArr.length];

                int a = 0;
                for(File f1:fileArr){
                        longArr[a] = f1.getFreeSpace();
                        a++;
                }
                Long[] longArr_copy = Arrays.copyOf(longArr,longArr.length); //排序前先做个副本，用于后面根据最值查原来的角标

                Arrays.sort(longArr);
                System.out.println("剩余空间最大的盘是：" + fileArr[Arrays.binarySearch(longArr_copy, longArr[fileArr.length-1])].toString().charAt(0) 
                        + "盘\t剩余：" + new DecimalFormat("0.000").format(longArr[fileArr.length-1]/1024.0/1024.0/1024.0) + "G");


/*              //②Map集合法：空间容量作为键（虽然做出来了，但容量作为键有些不合理，不能体现唯一性）
                File[] fileArr = File.listRoots();
                Map<Long, File> map = new TreeMap<Long, File>();
                for(File file :fileArr){
                    map.put(file.getFreeSpace(), file);
                }

                Iterator<Long> ite = map.keySet().iterator();
                while(true){
                    Long key =  ite.next();
                if(!ite.hasNext()){
                    String s= new DecimalFormat("0.0").format(key/1024.0/1024.0/1024.0);
                    System.out.println("剩余空间最大的盘是："+ map.get(key).toString().charAt(0) + "盘     "+ " 剩余  " + s + "G");
                    break;
                    }
                }

                //显示所有的盘符和剩余空间：             
//              Iterator<Long> it = map.keySet().iterator();
                for(Iterator<Long> it = map.keySet().iterator();it.hasNext();){
                        Long key = it.next();
                        File value = map.get(key);
                        String s= new DecimalFormat("0.0").format(key/1024.0/1024.0/1024.0);
                        System.out.println(value.toString().charAt(0) + " :  剩余  " + s + "G");
                }*/
            }


//目录内容获取和过滤：过滤器


        public static void listDemo(){
            File file = new File("D:\\");
//          for(String s: file.list()){
//              if(s.endsWith(".java"))   //手动过滤
//              System.out.println(s);
//          }


            //过滤器：
                    //需求1：只要D:\中.java文件。
/*          for(String s:file.list(new FilterByJava())){
                System.out.println(s);
            }*/

                //需求2：只要D:\中不是隐藏的.txt文件。
                //改进：因为常看隐藏属性，是File对象的功能，所以这里用listFiles()，返回目录列表的Files对象形式。
            for(File f:file.listFiles(new FilterByHidden())){
                System.out.println(f.getName());
            }


/*          for(String s:file.list(new SuffixFilter(".txt"))){    //提供构造方法的专属后缀名过滤器
                System.out.println(s);
            }
            */
        }

}

//过滤器
/*class FilterByJava implements FilenameFilter{  //文件名过滤器

    @Override
    public boolean accept(File dir, String name) {
            return name.endsWith(".java");
    }

}*/

class FilterByHidden implements FileFilter{  //文件过滤器

    @Override
    public boolean accept(File pathname) {
        if(!pathname.isHidden()){    //系统级隐藏文件的判断方式不一样，这里不考虑过滤系统级隐藏文件
            if(pathname.getName().endsWith(".txt"))
                return true;
        }           
        return false;
    }

}


//后缀名过滤器，提供构造函数，免得修改过滤器源码

class SuffixFilter implements FilenameFilter{

    private String suffix;
    public SuffixFilter(String suffix) {
//      super();
        this.suffix = suffix;
    }

    @Override
    public boolean accept(File dir, String name) {

        return name.endsWith(suffix);
    }
}
```

### 5.5.2 File对象—练习-深度遍历
```
import java.io.File;

public class FileTest {
	public static void main(String[]args)
	{
		File dir =new File("D:\\Workspace");
		
		listAll(dir,0);
	}

	private static void listAll(File dir,int level) {
		// TODO Auto-generated method stub
		System.out.println(getSpace(level)+dir.getName());
		
		level++;
		//获取指定目录下当前的所有文件夹或者文件对象
		File []files=dir.listFiles();
		
		for(int x=0;x<files.length;x++) {
			if(files[x].isDirectory())
				listAll(files[x],level);
			else
			   System.out.println(getSpace(level)+dir.getName());
		}
	}

	private static String getSpace(int level) {
		// TODO Auto-generated method stub
		
		StringBuilder sb=new StringBuilder();
		
		for(int x=0;x<level;x++) {
			sb.insert(0, "|   ");
		}
		return sb.toString();
	}
}

```
### 5.5.3 File对象—练习-递归
递归：函数自身直接或者间接的调用了自身。</br>
注意：
1. 递归一定要明确条件，否者容易栈溢出。
2. 注意递归的次数。

### 5.5.4 File对象—练习-删除目录
删除一个带内容的目录。

原理：必须从最里面往外删。</br>
需要进行深度遍历
```
import java.io.File;

public class RemoveDirTest {
	public static void main(String[]args)
	{
		File dir=new File("e:\\demodir");
		//dir.delete();
		removeDir(dir);
	}

	private static void removeDir(File dir) {
		// TODO Auto-generated method stub
		File []files=dir.listFiles();
		
		for(File file:files)
		{
			if(file.isDirectory()) {
				removeDir(file);
			}
			else {
				System.out.println(file+":"+file.delete());
			}
		}
		System.out.println(dir+":"+dir.delete());
	}
}

```
## 5.6 Properties集合
### 5.6.1 Properties集合-基本功能
Hashtable：内部机构是哈希表，是同步的。不允许null作为键和值。</br>
子类 Properties：用来存储键值对形式的配置文件的信息。可以和IO技术相结合。

Properties集合：</br>
特点：</br>
1.该集合中的键和值都是字符串类型。</br>
2.集合中的数据可以保存到流中，或者从流中获取。</br>

通过该集合用于操作以键值对形式存在的配置文件。</br> 还有一种，xml也是存储配置文件的。

特有方法：
1. 存:Object setProperty(String key, String value) </br>
    调用 Hashtable 的方法 put。 
2. 取：String getProperty(String key)</br> 
    用指定的键在此属性列表中搜索属性。
3. 全取： Set<String> stringPropertyNames() </br>
    返回此属性列表中的键集，其中该键及其对应值是字符串，如果在主属性列表中未找到同名的键，则还包括默认属性列表中不同的键。 

```
import java.util.Properties;
import java.util.Set;

public class PropertiesDemo {
	public static void main(String[]args)
	{
		//创建一个Properties集合。
		Properties prop=new Properties();
		
		//存储元素
		prop.setProperty("zhangsan", "30");
		prop.setProperty("lisi", "31");
		prop.setProperty("wangwu", "36");
		prop.setProperty("zhaoliu", "20");
		
		//修改元素
		prop.setProperty("wangwu", "26");//覆盖
		
		//取出所有元素
		Set<String> names=prop.stringPropertyNames();
		
		for(String name:names) {
			String value=prop.getProperty(name);
			System.out.println(name+":"+value);
		}
	}
}

```

### 5.6.2 Properties集合-list方法
prop.list(System.out);</br>
将集合的数据打印到显示台。
### 5.6.3 Properties集合-store方法
```
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Properties;

public class PropertiesDemo {
	public static void main(String[]args) throws IOException
	{
		//创建一个Properties集合。
		Properties prop=new Properties();
		
		//存储元素
		prop.setProperty("zhangsan", "30");
		prop.setProperty("lisi", "31");
		prop.setProperty("wangwu", "36");
		prop.setProperty("zhaoliu", "20");
		
		
		//想要将这些集合中的字符串键值信息持久化存储到文件中
		//需要关联输出流
		
		FileOutputStream fos=new FileOutputStream("info.txt");
		
		//将集合中的数据存储到文件中，使用store方法
		prop.store(fos, "name+age");
		
		//将数据存储到文件中，使用store方法
		prop.store(fos, "info");//注意字符编码ios
	}
}

```
### 5.6.4 Properties集合-修改配置信息
对已有的配置文件中的信息进行修改。

读取这个文件。</br>
并将这个文件的键值数据存储到集合中。</br>
再通过集合对数据进行修改。</br>
再通过流将修改后的集合存储到文件中。</br>
```
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Properties;

public class PropertiesDemo {
	public static void main(String[]args) throws IOException
	{
		//创建一个Properties集合。
		Properties prop=new Properties();
		
		//存储元素
		prop.setProperty("zhangsan", "30");
		prop.setProperty("lisi", "31");
		prop.setProperty("wangwu", "36");
		prop.setProperty("zhaoliu", "20");
		
		
		//想要将这些集合中的字符串键值信息持久化存储到文件中
		//需要关联输出流
		
		FileOutputStream fos=new FileOutputStream("info.txt");
		
		//将集合中的数据存储到文件中，使用store方法
		prop.store(fos, "name+age");
		
		//将数据存储到文件中，使用store方法
		prop.store(fos, "info");//注意字符编码ios
		
		//集合中的数据来自一个文件。
		//注意：必须保证该文件中的数据是键值对
		//需要使用到读取流
		FileInputStream fis=new FileInputStream("info.txt");
		
		//使用load方法
		prop.load(fis);
		
		prop.list(System.out);
		
		test();
	}
	private static void test() throws IOException {
		// TODO Auto-generated method stub
		//读取这个文件
		File file=new File("info.txt");
		if(!file.exists())
		{
			file.createNewFile();
		}
		FileReader fr=new FileReader("info.txt");
		
		//创建集合存储配置信息
		Properties prop=new Properties();
		
		//将流中信息存储到集合中
		prop.load(fr);
		
		prop.setProperty("wangwu", "16");
		
		FileWriter fw=new FileWriter(file);
		
		prop.store(fw, "");
		
		fw.close();
		fr.close();
	}
	public static void myload() throws IOException   {
		Properties prop=new Properties();
		BufferedReader bufr=new BufferedReader(new FileReader("info.txt"));
		
		String line=null;
		while((line=bufr.readLine())!=null)
		{
			if(line.startsWith("#"))
				continue;
			String []arr=line.split("=");
			System.out.println(arr[0]+"::"+arr[1]);
		}
		bufr.close();
	}
}

```
### 5.6.5 Properties集合-练习
定义定义功能，获取一个应用程序运行的次数，如果超过5次，给出使用次数已到，请注册的提示。并不要再运行程序。

思路：
1. 应该有计数器。</br>
每次程序启动都需要计数一次，并且是再原有的次数上进行计数。
2. 计数器就是一个变量。程序启动时进行计数，计数器必须存在于内存并进行运算。</br>
可是程序一结束，计数器消失了。那么再次启动该程序，计数器又重新被初始化。</br>
而我们需要多次启动同一个应用程序，使用的是同一个计数器。</br>
这就需要计数器的生命周期变长，从内存存储到硬盘文件中。
3. 如何使用这个计数器。   </br> 首先，程序启动时，应该先读取这个用于记录计数器信息的配置文件。</br>
获取上一次计数器次数。并进行使用次数的判断。</br>
其次，对该次数进行自增，并把自增后的次数重新存储到配置文件中。</br>
4. 文件中的信息进行存储并体现。</br>
直接存储次数值可以，但是不明确该数据的含义。所以起名字很重要。</br>
这就有了名字和值的对应，所以可以使用键值对。</br>
可以使用映射关系map集合搞定，又需要读取硬盘上的数据，所以map + io = Properties。</br>
如果是更复杂的数据，用xml。
```
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Properties;

public class PropertiesTest {
	public static void main(String[]args)
	{
		getAppCount();
	}
	
	public static void getAppCount() throws IOException
	{
		//将配置文件封装成File对象
		File confile =new File("count.properties");
		
		FileInputStream fis=new FileInputStream(confile);
		
		if(!confile.exists()) {
			confile.createNewFile();
		}
		
		Properties prop=new Properties();
		
		prop.load(fis);
		
		//从集合中通过键获取次数。
		String value=prop.getProperty("time");
		
		//定义计算器。记录获取的次数
		int count=0;
		if(value!=null)
		{
			count=Integer.parseInt(value);
			if(count>=5) {
				/*System.out.println("使用次数已到，请注册，给钱！");
				return;*/
				throw new RuntimeException("使用次数已到，请注册，给钱！");
			}
		}
		count++;
		
		//将改变后的次数重新存储到集合中
		prop.setProperty("time", count+"");
		
		FileOutputStream fos=new FileOutputStream(confile);
		
		prop.store(fos, "");
		
		fos.close();
		fis.close();
	}
}

```
### 5.6.6 综合练习-文件清单列表
需求：</br>
获取指定目录下，指定扩展名的文件(包含子目录中的)</br>
这些文件的绝对路径写入到一个文本文件中。

就是建立一个指定扩展名的文件的列表。

思路：
1. 必须进行深度遍历
2. 要在遍历的过程中进行过滤。将符合条件的内容，都存储到容器中。
3. 对容器中的内容进行遍历并将绝对路径写到文件中。
```
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class Test {
	public static void main(String[]args)
	{
		File dir=new File("e:\\java0331");
		
		FilenameFilter filter=new FilenameFilter(){
			public boolean accept(File dir,String name) {
				return name.endsWith(".java");
			}
		}
		
		List<File> list=new ArrayList<File>();
		
		getFiles(dir,filter,list);
		
		File destFile=new File(dir,"javalist.txt");
		
		write2File(list,destFile);
	}
	public static List getFiles(File dir,FilenameFilter filter,List<File> list)
	{
		File[] files=dir.listFiles();
		
		for(File file:files){
			if(file.isDirectory()) {
				//递归
				getFiles(file,filter,list);
			}else {
				//对遍历到的文件进行过滤器的过滤。将符合条件File对象存入list中
				if(filter.accept(dir, file.getName())) {
					list.add(file);
					}
			}
		}
	}
	public static void write2File(List<File>list,File destFile) throws IOException
	{
		BufferedWriter bufw=null;
		try {
			bufw=new BufferedWriter(new FileWriter(destFile));
			for(File file:list)
			{
				bufw.write(file.getAbsolutePath());
				bufw.newLine();
				bufw.flush();
			}
		}catch(IOException e)
		{
			throw new RuntimeException("写入失败！"); 
		}finally {
			if(bufw!=null)
				try{
					bufw.close();
				}catch(IOException e) {
					throw new RuntimeException("关闭失败！");
				}
		}
	}
}

```
## 5.7 打印流
### 5.7.1 打印流-PrintStream
打印流PrintStream:字节流的扩展形式。print()将字节流封装成了字符流。</br>
1. 提供了打印方法可以对多种数值类型进行打印。并保持数据的表现形式。
2. 它不抛IOException

构造函数，接收三种类型的值
1. 字符串路径
2. File对象
3. 字符输出流
```
import java.io.IOException;
import java.io.PrintStream;

public class PrintDemo {
	public static void main(String[]args) throws IOException
	{
		PrintStream out=new PrintStream("print.txt");
		
		out.write(97);//a，只写最第8位
		
		//out.print(97);//将97先变成字符串保持原样将数据打印到目的地。
		out.close();
	}
}
```
注意：
1. out.write(97);//a，只写最第8位
2. out.print(97);//将97先变成字符串保持原样将数据打印到目的地。

### 5.7.2 打印流-PrintWriter
PrintWriter:字符打印流。</br>
构造函数参数
1. 字符串路径。
2. File对象
3. 字节输出流
4. 字符输出流
 
PrintWriter(Writer out, boolean autoFlush) ：创建新 PrintWriter。

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;

public class PrintWriterDemo {
	public static void main(String[]args) throws IOException {
		
		/**PrintWriter:字符打印流。
		 * 构造函数参数
		 * 1.字符串路径。
		 * 2.File对象
		 * 3.字节输出流
		 * 4.字符输出流
		 * */
		BufferedReader bufr=new BufferedReader(new InputStreamReader(System.in));
		
		//PrintWriter out=new PrintWriter(System.out,true);
		
		PrintWriter out=new PrintWriter(new FileWriter("out.txt"),true);
		String line=null;
		while((line=bufr.readLine())!=null) {
			if("over".equals(line))
				break;
			out.println(line.toUpperCase());
			//autoFlush - boolean 变量；如果为 true，则 println、printf 或 format 方法将刷新输出缓冲区
			
			//out.flush();
			
		}
		
		out.close();
		bufr.close();
	}
}

```
## 5.8 序列流
### 5.8.1 序列流-SequenceInputStream
需求：将1.txt 2.txt 3.txt文件中的数据合并到一个文件中
```
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.SequenceInputStream;
import java.util.Enumeration;
import java.util.Vector;

public class SequenceInputStreamDemo {
	public static void main(String[]args) throws IOException
	{
		
		Vector<FileInputStream> v=new Vector<FileInputStream>();
		
		v.add(new FileInputStream("a.txt"));
		v.add(new FileInputStream("b.txt"));
		v.add(new FileInputStream("c.txt"));
		
		Enumeration<FileInputStream> en=v.elements();
		
		SequenceInputStream sis=new SequenceInputStream(en);
		
		FileOutputStream fos=new FileOutputStream("4.txt");
		
		byte[]buf=new byte[1024];
		
		int len=0;
		
		while((len=sis.read(buf))!=-1)
		{
			fos.write(buf,0,len);
		}
		fos.close();
		sis.close();
	}
}
```
### 5.8.2 序列流-SequenceInputStream-枚举和迭代
用工具类Collections
```
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.SequenceInputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;

public class SequenceInputStreamDemo {
	public static void main(String[]args) throws IOException
	{
		
		ArrayList<FileInputStream> a1=new ArrayList<FileInputStream>();
		for(int x=1;x<3;x++)
		{
			a1.add(new FileInputStream(x+".txt"));
		}
		
		Enumeration<FileInputStream> en=Collections.enumeration(a1);
		
		/*final Iterator<FileInputStream> it=a1.iterator();
		
		Enumeration<FileInputStream> en=new Enumeration<FileInputStream>(){

			@Override
			public boolean hasMoreElements() {
				// TODO Auto-generated method stub
				return it.hasNext();
			}

			@Override
			public FileInputStream nextElement() {
				// TODO Auto-generated method stub
				return it.next();
			}
			
		};*/
		
		SequenceInputStream sis=new SequenceInputStream(en);
		
		FileOutputStream fos=new FileOutputStream("4.txt");
		
		byte[]buf=new byte[1024];
		
		int len=0;
		
		while((len=sis.read(buf))!=-1)
		{
			fos.write(buf,0,len);
		}
		fos.close();
		sis.close();
	}
}

```
## 5.9 文件切割和合并
### 5.9.1 文件切割
```
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class SplitFileDemo {
	private static final int SIZE = 1024*1024;

	public static void main(String[]args) throws IOException
	{
		File file =new File("c:\\0.bmp");
		spiltFile(file);
	}
	
	public static void spiltFile(File file) throws IOException {
		//用读取关联源文件。
		FileInputStream fis =new FileInputStream(file);
		
		//定义一个1M的缓冲区
		byte[]buf=new byte[SIZE];
		
		//创建目的
		FileOutputStream fos=null;
		
		int len=0;
		int count=1;
		
		File dir=new File("c:\\partfiles");
		if(!dir.exists())
			dir.mkdirs();
		while((len=fis.read(buf))!=-1)
		{
			fos=new FileOutputStream(new File(dir,(count++)+".part"));
			fos.write(buf,0,len);
		}
	}
}
```
### 5.9.2 文件合并
```
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.SequenceInputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;

public class MergeFile {
	public static void main(String[]args) {
		File dir=new File("c:\\partfiles");
	}
	
	public static void mergeFile(File dir) throws IOException {
		
		ArrayList<FileInputStream> al=new ArrayList<FileInputStream>();
		
		for(int x=1;x<=3;x++)
		{
			al.add(new FileInputStream(new File(dir,x+".part")));
		}
		
		Enumeration<FileInputStream> en=Collections.enumeration(al);
		
		SequenceInputStream sis=new SequenceInputStream(en);
		
		FileOutputStream fos=new FileOutputStream(new File(dir,"1.bmp"));
		
		byte [] buf=new byte[1024];
		int len=0;
		while((len=sis.read(buf))!=-1)
		{
			fos.write(buf,0,len);
		}
		fos.close();
		sis.close();
	}
}
```
### 5.9.3 文件合并+配置信息
切割文件时，必须记录住被切割文件的名称，以及切割出来碎片的个数，以方便于合并。</br>
这个信息为了进行描述，使用键值对的方式，用到了Properties对象。
```
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.SequenceInputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.Properties;

public class MergeFile {
	private static final int SIZE = 1024*1024;
	public static void main(String[]args) throws IOException {
		File dir=new File("c:\\partfiles");
		
		spiltFile_2(dir);
		
		mergeFile_2(dir);
	}
	
	public static void mergeFile_2(File dir) throws IOException {
		
		
		//获取指定目录下的配置文件对象
		File []files=dir.listFiles(new SuffixFilter(".properties"));
		
		if(files.length!=1)
			throw new RuntimeException(dir+",该目录下没有properties扩展名的文件或者不唯一");
		//记录配置文件对象
		File confile =files[0];
		
		
		
		
		
		
		
		//获取该文件中的信息================================================
		Properties prop=new Properties();
		
		FileInputStream fis=new FileInputStream(confile);
		
		prop.load(fis);
		String filename=prop.getProperty("filename");
		int count =Integer.parseInt(prop.getProperty("partcount"));
		
		
		
		
		
		//获取该目录下所有的碎片文件===============================================
		File []partFiles=dir.listFiles(new SuffixFilter(".part"));
		
		if(partFiles.length!=(count-1))
		{
			throw new RuntimeException("碎片文件不符合要求。个数不对！应该"+count+"个")
		}
	
		
		
		
		
		
		//将碎片文件和流对象关联并存储到集合中。
		ArrayList<FileInputStream> al=new ArrayList<FileInputStream>();
		for(int x=0;x<partFiles.length;x++)
		{
			al.add(new FileInputStream(new File(dir,x+".part")));
		}
		
		
		
		//将多个流合并成一个系列流。
		Enumeration<FileInputStream> en=Collections.enumeration(al);
		
		SequenceInputStream sis=new SequenceInputStream(en);
		
		FileOutputStream fos=new FileOutputStream(new File(dir,filename));
		
		byte [] buf=new byte[1024];
		int len=0;
		while((len=sis.read(buf))!=-1)
		{
			fos.write(buf,0,len);
		}
		fos.close();
		sis.close();
	}
	
	public static void spiltFile_2(File file) throws IOException {
		//用读取关联源文件。
		FileInputStream fis =new FileInputStream(file);
		
		//定义一个1M的缓冲区
		byte[]buf=new byte[SIZE];
		
		//创建目的
		FileOutputStream fos=null;
		
		//切割文件时，必须记录住被切割文件的名称，以及切割出来碎片的个数，以方便于合并。
		//这个信息为了进行描述，使用键值对的方式，用到了Properties对象。
		
		Properties prop=new Properties();
		
		
		int len=0;
		int count=1;
		
		File dir=new File("c:\\partfiles");
		if(!dir.exists())
			dir.mkdirs();
		while((len=fis.read(buf))!=-1)
		{
			fos=new FileOutputStream(new File(dir,(count++)+".part"));
			fos.write(buf,0,len);
			fos.close();
		}
		
		//将被切割文件的信息保存到prop集合中
		prop.setProperty("partcount", count+"");
		prop.setProperty("filename", file.getName());
		
		fos=new FileOutputStream(new File(dir,count+"properties"));
		
		//将prop集合中的数据存储到文件中
		prop.store(fos, "save file info");
		fos.close();
		fis.close();
	}
}

```
## 5.10 操作对象
### 5.10.1 ObjectOutputStream-对象化的序列化
ObjectOutputStream:</br>
将 Java 对象的基本数据类型和图形写入 OutputStream。</br>
通过在流中使用文件可以实现对象的持久存储。</br>
对象的默认序列化机制写入的内容是：对象的类，类签名，以及非瞬态和非静态字段的值。</br>
被操作的对象需要实现Serializable（标记接口）
```
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;

public class ObjectStreamDemo {
	public static void main(String[]args) throws IOException
	{
		writeObj();
	}

	private static void writeObj() throws IOException, IOException {
		// TODO Auto-generated method stub
		ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream("obj.txt"));
		//被操作的对象需要实现Serializable（标记接口）
		oos.writeObject(new Person("小强",30));
		
		oos.close();
	}

}
import java.io.Serializable;

public class Person implements Serializable{
	private String name;
	private int age;
	public Person(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
}
```
### 5.10.2 ObjectInputStream-对象化的反序列化
ObjectInputStream 对以前使用 ObjectOutputStream 写入的基本数据和对象进行反序列化。 
```
import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;

public class ObjectStreamDemo {
	public static void main(String[]args) throws IOException, ClassNotFoundException
	{
		readObj();
	}

	private static void readObj() throws IOException, IOException, ClassNotFoundException {
		// TODO Auto-generated method stub
		ObjectInputStream ois=new ObjectInputStream(new FileInputStream("obj.object"));
		
		//必须要同时有object文件，也要class文件
		Person p=(Person)ois.readObject();
		System.out.println(p.getName()+":"+p.getAge());
		ois.close();
	}
}

```
### 5.10.3 序列化接口—Serializable
1. 如果序列化的类改变了，id号会变。反序列化会发生异常。
2. 所以安全起见，自己显示声明id号。这样，如果序列化的类改变了，id号不会变。
```
import java.io.Serializable;

public class Person implements Serializable{
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private String name;
	private int age;
	public Person(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	
}

```
### 5.10.4 关键字-transient
如果想要非静态的值不被序列化对象存储，加瞬态关键字transient
```
import java.io.Serializable;

public class Person implements Serializable{
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private transient String name;
	private static int age;
	public Person(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	
}

```
## 5.11 IO-其他类-RandomAccessFile
### 5.11.1 RandomAccessFile 写入
支持对随机访问文件的读取和写入。

特点：
1. 该对象即能读，又能写。
2. 该对象内部维护了一个byte数组，并通过指针可以操作数组中的元素。
3. 其实该对象就是将字节输入流和输出流进行了封装。
4. 其实该对象就是将字节输入流和输出流进行了封装。
5. 该对象的源或者只能是文件。通过构造函数就可以看出。

//使用RandomAccessFile对象写入一些人员信息，比如姓名和年龄。

1. "r" 以只读方式打开。调用结果对象的任何 write 方法都将导致抛出 IOException。  
2. "rw" 打开以便读取和写入。如果该文件尚不存在，则尝试创建该文件。  
3. "rws" 打开以便读取和写入，对于 "rw"，还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备。  
4. "rwd"   打开以便读取和写入，对于 "rw"，还要求对文件内容的每个更新都同步写入到底层存储设备。 
```
import java.io.IOException;
import java.io.RandomAccessFile;

public class RomdomAccessFileDemo {
	public static void main(String[]args) throws IOException
	{
		writeFile();
	}
	
	public static void writeFile() throws IOException
	{
		
		//如果文件不存在，则创建，如果文件存在，不创建。
		RandomAccessFile raf=new RandomAccessFile("ranacc.txt","rw");
		
		raf.write("张三".getBytes());
		raf.write(97);  //a
		raf.writeInt(607);//-a
		raf.close();
	}	
}
```
### 5.11.2 RandomAccessFile-读取&随机读取
通过seek设置指针的位置。
```
import java.io.IOException;
import java.io.RandomAccessFile;

public class RomdomAccessFileDemo {
	public static void main(String[]args) throws IOException
	{
		readFile();
	}

	public static void readFile() throws IOException {
		// TODO Auto-generated method stub
		RandomAccessFile raf=new RandomAccessFile("ranacc","rw");
		
		//通过seek设置指针的位置
		raf.seek(1*8);    //随机读取，只要指定指针的位置即可。
		
		byte[] buf=new byte[4];
		raf.read(buf);
		
		String name=new String(buf);
		System.out.println("name="+name);
		
		int age=raf.readInt();
		System.out.println("age:"+age);
		
		System.out.println("pos:"+raf.getFilePointer());
		
		raf.close();
	}
}
```
### 5.11.3 RandomAccessFile-随机写入&细节
seek指定位置写入数据

使用环境：
1. 读取有规律的文本
2. 多个线程同时写一个文本的不同位置。（其他流都是从头开始写，所以做不到）
## 5.11 IO-其他类-管道流
### 5.11.1 管道流-PipedStream
```
import java.io.PipedInputStream;

public class Input implements Runnable {
	private PipedInputStream in;
	Input(PipedInputStream in)
	{
		this.in=in;
	}
	
	public void run() {
		try {
			byte[]buf=new byte[1024];
			int len=in.read(buf);
			
			String s=new String(buf,0,len);
			System.out.println("s="+s);
			
			in.close();
		}catch(Exception e) {
			
		}
	}
}

import java.io.PipedOutputStream;

public class Output implements Runnable{
	private PipedOutputStream out;

	public Output(PipedOutputStream out) {
		super();
		this.out = out;
	}
	
	public void run()
	{
		try {
			out.write("hi,管道来了".getBytes());
			
		}catch(Exception e) {
			
		}
	}
}
package mypackage;

import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;

public class PipedStream {
	public static void main(String[]args) throws IOException
	{
		PipedInputStream input=new PipedInputStream();
		PipedOutputStream output=new PipedOutputStream();
		
		input.connect(output);
		
		new Thread(new Input(input)).start();
		new Thread(new Output(output)).start();
		
	}
}
```
## 5.12 操作基本数据类型数据的流对象-DataStream
```
package mypackage;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class DateStreamDemo {
	public static void main(String[]args) throws IOException 
	{
		writeDate();
		readDate();
		
	}

	private static void readDate() throws IOException {
		// TODO Auto-generated method stub
		DataInputStream dis=new DataInputStream(new FileInputStream("data.txt"));
		
		String str=dis.readUTF();
		
		System.out.println(str);
	}

	private static void writeDate() throws IOException {
		// TODO Auto-generated method stub
		DataOutputStream dos=new DataOutputStream(new FileOutputStream("data.txt"));
		
		dos.writeUTF("你好");
		
		dos.close();
	}
}
```
## 5.13 操作数组的流
```
package mypackage;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;

public class ByteArrayStreamDemo {
	public static void main(String[]args)
	{
		ByteArrayInputStream bis=new ByteArrayInputStream("abcdef".getBytes());
		
		ByteArrayOutputStream bos=new ByteArrayOutputStream();
		
		int ch=0;
		while((ch=bis.read())!=-1) {
			bos.write(ch);
		}
		
		//内存
		System.out.println(bos.toString());
	}
}

```
## 5.13 编码表
### 5.13.1 简单的编码解码
```
package mypackage;

import java.io.UnsupportedEncodingException;

public class EncodeDemo {
	public static void main(String[]agrs) throws UnsupportedEncodingException
	{
		//字符串-->字节编码：编码
		//字符数组-->字符串：解码
		//你好： GBK: -60  -29  -70  -61
		//你好：utf-8：-28  -67  -96  -27  -91  -67
		
		String str="你好";
		
		//编码
		byte[] buf=str.getBytes("utf-8");
		
		printBytes(buf);
		
		//解码
		String s1=new String(buf);
		
		System.out.println("s1="+s1);
		
	}

	private static void printBytes(byte[] buf) {
		// TODO Auto-generated method stub
		for(byte b:buf) {
			System.out.println(b);
		}
	}
}

```
### 5.13.2 编码解码问题
注意：解码可能会失败
```
import java.io.UnsupportedEncodingException;

public class EncodeDemo {
	public static void main(String[]agrs) throws UnsupportedEncodingException
	{
		//字符串-->字节编码：编码
		//字符数组-->字符串：解码
		//你好： GBK: -60  -29  -70  -61
		//你好：utf-8：-28  -67  -96  -27  -91  -67
		
		String str="你好";
		
		byte[] buf=str.getBytes("utf-8");
		
		String s1=new String(buf,"utf-8");
		
		System.out.println("s1="+s1);
		
		byte[]buf2=s1.getBytes("utf-8");//获取源字节
		
		printBytes(buf2);//-17 -65 -67 -17 -65 -67 -17 -65 -67
		String s2=new String(buf2,"GBK");
		
		System.out.println("s2="+s2);
	}

	private static void printBytes(byte[] buf) {
		// TODO Auto-generated method stub
		for(byte b:buf) {
			System.out.println(b);
		}
	}
}

```
### 5.13.3 联通问题
```
package mypackage;

import java.io.UnsupportedEncodingException;

public class LianTong {
	public static void main(String[]args) throws UnsupportedEncodingException
	{
		String str="联通";
		
		/*11000001
		10101010
		11001101
		10101000*/
		
		byte []buf=str.getBytes("gbk");
		
		for(byte b:buf)
		{
			System.out.println(Integer.toBinaryString(b&255));
		}
	}
}

```
### 5.13.4 练习-按照字节截取字符串
```
package mypackage;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.UnsupportedEncodingException;

public class ByteArrayStreamDemo {
	public static void main(String[]args) throws UnsupportedEncodingException
	{
		ByteArrayInputStream bis=new ByteArrayInputStream("abcdef".getBytes());
		
		ByteArrayOutputStream bos=new ByteArrayOutputStream();
		
		int ch=0;
		while((ch=bis.read())!=-1) {
			bos.write(ch);
		}
		
		//内存
		System.out.println(bos.toString());
		
		String str="ab你好cd谢谢";
		
		int len=str.getBytes("gbk").length;
		
		for(int x=0;x<len;x++)
		{
			System.out.println("截取"+(x+1)+"个字符结果是："+outStringByByte(str,x+1));
		}
		
		str="琲";
		
		byte []buf=str.getBytes("gbk");
		for(byte b:buf)
		{
			System.out.println(b);//-84   106
		}
	}
	public static String outStringByByte(String str,int len) throws UnsupportedEncodingException
	{
		byte[]buf=str.getBytes("gbk");
		
		int count=0;
		for(int x=len-1;x>=0;x--)
		{
			if(buf[x]<0)
				count++;
			else 
				break;
		}
		if(count%2==0)
			return new String(buf,0,len,"gbk");
		else 
			return new String(buf,0,len-1,"gbk");
	}
}

```